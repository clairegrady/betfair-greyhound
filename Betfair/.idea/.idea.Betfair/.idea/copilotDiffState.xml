<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Betfair/AutomationServices/HorseRacingAutomationService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Betfair/AutomationServices/HorseRacingAutomationService.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Text.Json;&#10;using System.Text.Json.Serialization; // Required for [JsonPropertyName]&#10;using System.Threading.Tasks; // Required for async/await&#10;&#10;// Assuming these namespaces are correct for your models and services&#10;using Betfair.Data; // For ListMarketCatalogueDb, MarketBookDb&#10;using Betfair.Models; // For ApiResponse&#10;using Betfair.Models.Market; // For MarketBook, MarketCatalogue&#10;using Betfair.Models.Runner; // For ApiRunner, RunnerDescription, RunnerFlat, RunnerMetadata&#10;using Betfair.Services; // For IMarketApiService, IEventService&#10;&#10;namespace Betfair.AutomationServices&#10;{&#10;    // --- START: Models (Ensuring they are correctly defined with JsonPropertyName) ---&#10;    // You should have these in their respective files (e.g., Models/Runner/RunnerFlat.cs, Models/Runner/RunnerMetadata.cs)&#10;    // I'm including them here for completeness based on our discussion, but put them in their proper files.&#10;&#10;    public class HorseRacingAutomationService&#10;    {&#10;        private readonly IMarketApiService _marketApiService;&#10;        private readonly ListMarketCatalogueDb _listMarketCatalogueDb;&#10;        private readonly MarketBookDb _marketBookDb;&#10;        private readonly IEventService _eventService;&#10;&#10;        // New field to store runner descriptions for lookup&#10;        private Dictionary&lt;long, RunnerDescription&gt; _runnerDescriptionsLookup;&#10;        private Dictionary&lt;string, MarketCatalogue&gt; _marketCatalogueLookup = new();&#10;&#10;        public HorseRacingAutomationService(&#10;            IMarketApiService marketApiService,&#10;            ListMarketCatalogueDb listMarketCatalogueDb,&#10;            MarketBookDb marketBookDb,&#10;            IEventService eventService)&#10;        {&#10;            _marketApiService = marketApiService;&#10;            _listMarketCatalogueDb = listMarketCatalogueDb;&#10;            _marketBookDb = marketBookDb;&#10;            _eventService = eventService;&#10;&#10;            // Initialize the lookup dictionary&#10;            _runnerDescriptionsLookup = new Dictionary&lt;long, RunnerDescription&gt;();&#10;            _marketCatalogueLookup = new Dictionary&lt;string, MarketCatalogue&gt;();&#10;        }&#10;&#10;        // Method 1: GetAndProcessHorseRacingMarketCataloguesAsync (fetches descriptions)&#10;        public async Task&lt;List&lt;MarketCatalogue&gt;&gt; GetAndProcessHorseRacingMarketCataloguesAsync(string eventId = null)&#10;        {&#10;            var today = DateTime.UtcNow.Date;&#10;&#10;            //Console.WriteLine($&quot;--- GetAndProcessHorseRacingMarketCataloguesAsync: Fetching Market Catalogues for today ({today:yyyy-MM-dd}) ---&quot;);&#10;            var marketCatalogueJson = await _marketApiService.ListHorseRacingMarketCatalogueAsync(eventTypeId: &quot;7&quot;, openDate: today);&#10;&#10;            Console.WriteLine(&quot;--- Raw Market Catalogue JSON (full) ---&quot;);&#10;            Console.WriteLine(marketCatalogueJson);&#10;&#10;            //Console.WriteLine(&quot;--- Raw Market Catalogue JSON (first 500 chars) ---&quot;);&#10;            //Console.WriteLine(marketCatalogueJson.Substring(0, Math.Min(500, marketCatalogueJson.Length)));&#10;&#10;            //Console.WriteLine(&quot;--- Attempting Deserialization of Market Catalogue ---&quot;);&#10;&#10;            ApiResponse&lt;MarketCatalogue&gt; apiResponse;&#10;&#10;            try&#10;            {&#10;                // Define JsonSerializerOptions to handle case-insensitivity, ignore nulls, and allow trailing commas&#10;                var options = new JsonSerializerOptions&#10;                {&#10;                    PropertyNameCaseInsensitive = true,  // Handle case-insensitive property names&#10;                    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull, // Ignore nulls&#10;                    AllowTrailingCommas = true  // Allow trailing commas in JSON&#10;                };&#10;&#10;                // Deserialize the overall API response wrapper with the specified options&#10;                apiResponse = JsonSerializer.Deserialize&lt;ApiResponse&lt;MarketCatalogue&gt;&gt;(marketCatalogueJson, options);&#10;&#10;               //Console.WriteLine($&quot;Deserialization successful. Market Catalogue API Response Result property is {(apiResponse?.Result != null ? &quot;not null&quot; : &quot;null&quot;)}.&quot;);&#10;&#10;                if (apiResponse?.Result != null)&#10;                {&#10;                   //Console.WriteLine($&quot;Market catalogues received (apiResponse.Result.Count): {apiResponse.Result.Count}&quot;);&#10;                }&#10;            }&#10;            catch (JsonException ex)&#10;            {&#10;                // Handle JSON parsing errors (log, rethrow, etc.)&#10;               //Console.WriteLine($&quot;JSON Deserialization ERROR for Market Catalogue: {ex.Message}&quot;);&#10;               //Console.WriteLine($&quot;JSON Path: {ex.Path}, LineNumber: {ex.LineNumber}, BytePositionInLine: {ex.BytePositionInLine}&quot;);&#10;                return new List&lt;MarketCatalogue&gt;(); // Return empty list on deserialization error&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                // Handle other types of exceptions&#10;               //Console.WriteLine($&quot;General Deserialization ERROR for Market Catalogue: {ex.Message}&quot;);&#10;                return new List&lt;MarketCatalogue&gt;(); // Return empty list on other errors&#10;            }&#10;&#10;            var marketCatalogues = apiResponse?.Result ?? new List&lt;MarketCatalogue&gt;();&#10;&#10;            _marketCatalogueLookup = marketCatalogues&#10;                .Where(mc =&gt; !string.IsNullOrEmpty(mc.MarketId))&#10;                .ToDictionary(mc =&gt; mc.MarketId, mc =&gt; mc);&#10;&#10;           //Console.WriteLine($&quot;Final processed market catalogues count: {marketCatalogues.Count}&quot;);&#10;&#10;            if (marketCatalogues.Any())&#10;            {&#10;               //Console.WriteLine(&quot;--- Verifying Market Catalogue Contents (Post-Deserialization) ---&quot;);&#10;                foreach (var market in marketCatalogues.Take(2)) // Print details for first 2 markets&#10;                {&#10;                   //Console.WriteLine($&quot;\nMarket Id: {market.MarketId}, Market Name: {market.MarketName}, Event: {market.Event?.Name}&quot;);&#10;&#10;                    if (market.Runners != null)&#10;                    {&#10;                       //Console.WriteLine($&quot;  Runners in this Market: {market.Runners.Count}&quot;);&#10;                        foreach (var runnerDescription in market.Runners.Take(3)) // Print first 3 runners per market&#10;                        {&#10;                            var metadata = runnerDescription.Metadata;&#10;                           //Console.WriteLine($&quot;    Runner Name: {runnerDescription.RunnerName}&quot;);&#10;                            if (metadata != null)&#10;                            {&#10;                                // This output should now show actual values, confirming Metadata is populated&#10;                               //Console.WriteLine($&quot;      Form: '{metadata.Form ?? &quot;NULL&quot;}'&quot;);&#10;                               //Console.WriteLine($&quot;      SireName: '{metadata.SireName ?? &quot;NULL&quot;}'&quot;);&#10;                               //Console.WriteLine($&quot;      Bred: '{metadata.Bred ?? &quot;NULL&quot;}'&quot;);&#10;                               //Console.WriteLine($&quot;      JockeyClaim: '{metadata.JockeyClaim ?? &quot;NULL&quot;}'&quot;); // Check nulls here&#10;                               //Console.WriteLine($&quot;      OfficialRating: '{metadata.OfficialRating ?? &quot;NULL&quot;}'&quot;); // Check nulls here&#10;                            }&#10;                            else&#10;                            {&#10;                               //Console.WriteLine($&quot;      No Metadata available for Runner: {runnerDescription.RunnerName}&quot;);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;               //Console.WriteLine(&quot;--- Finished Market Catalogue Content Verification ---&quot;);&#10;&#10;                // Populate the lookup dictionary after successful catalogue retrieval&#10;                PopulateRunnerDescriptionsLookup(marketCatalogues);&#10;            }&#10;            else&#10;            {&#10;               //Console.WriteLine(&quot;No market catalogues found.&quot;);&#10;            }&#10;            return marketCatalogues;&#10;        }&#10;&#10;        // Method to populate the lookup dictionary (called internally)&#10;        public void PopulateRunnerDescriptionsLookup(List&lt;MarketCatalogue&gt; marketCatalogues)&#10;        {&#10;            _runnerDescriptionsLookup.Clear(); // Clear any previous data&#10;&#10;            foreach (var marketCatalogue in marketCatalogues)&#10;            {&#10;                if (marketCatalogue.Runners != null)&#10;                {&#10;                    foreach (var runnerDescription in marketCatalogue.Runners)&#10;                    {&#10;                        // Log the metadata for debugging purposes&#10;                        Console.WriteLine($&quot;Runner SelectionId: {runnerDescription.SelectionId}, OwnerName: {runnerDescription.Metadata?.OwnerName}&quot;);&#10;&#10;                        // Use SelectionId as the key for lookup&#10;                        if (!_runnerDescriptionsLookup.ContainsKey(runnerDescription.SelectionId))&#10;                        {&#10;                            _runnerDescriptionsLookup.Add(runnerDescription.SelectionId, runnerDescription);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            Console.WriteLine($&quot;Populated RunnerDescriptionsLookup with {_runnerDescriptionsLookup.Count} unique runners.&quot;);&#10;        }&#10;&#10;&#10;        // Method 2: ProcessHorseMarketBooksAsync (fetches prices/status and combines with descriptions)&#10;       // Inside HorseRacingAutomationService.cs&#10;public async Task&lt;List&lt;RunnerFlat&gt;&gt; ProcessHorseMarketBooksAsync(List&lt;string&gt; marketIds)&#10;{&#10;   //Console.WriteLine($&quot;--- Starting ProcessHorseMarketBooksAsync for {marketIds.Count} market IDs ---&quot;);&#10;&#10;    if (marketIds == null || !marketIds.Any())&#10;    {&#10;       //Console.WriteLine(&quot;ProcessHorseMarketBooksAsync: No market IDs provided or list is null.&quot;);&#10;        return new List&lt;RunnerFlat&gt;();&#10;    }&#10;&#10;    // Important: Check if lookup data is available&#10;    if (!_runnerDescriptionsLookup.Any())&#10;    {&#10;       //Console.WriteLine(&quot;ProcessHorseMarketBooksAsync: Runner descriptions lookup is empty. Ensure GetAndProcessHorseRacingMarketCataloguesAsync was called and populated it.&quot;);&#10;        // This is a critical warning. If the lookup is empty, all metadata will be null.&#10;        // You might want to throw an exception or return an empty list here if having metadata is mandatory.&#10;    }&#10;    else&#10;    {&#10;       //Console.WriteLine($&quot;ProcessHorseMarketBooksAsync: Runner descriptions lookup contains {_runnerDescriptionsLookup.Count} unique runners.&quot;);&#10;    }&#10;&#10;&#10;    try&#10;    {&#10;        // Step 1: Fetch and deserialize MarketBook JSON&#10;       //Console.WriteLine($&quot;ProcessHorseMarketBooksAsync: Calling ListMarketBookAsync for {marketIds.Count} market IDs.&quot;);&#10;        var marketBookJson = await _marketApiService.ListMarketBookAsync(marketIds);&#10;       //Console.WriteLine($&quot;ProcessHorseMarketBooksAsync: Received MarketBook JSON. Length: {marketBookJson?.Length ?? 0}.&quot;);&#10;&#10;        // Print a sample of the MarketBook JSON&#10;       //Console.WriteLine(&quot;--- MarketBook JSON Sample (first 500 chars) ---&quot;);&#10;       //Console.WriteLine(marketBookJson?.Substring(0, Math.Min(500, marketBookJson.Length)) ?? &quot;NULL JSON received&quot;);&#10;       //Console.WriteLine(&quot;---------------------------------------------&quot;);&#10;&#10;&#10;        var marketBookApiResponse = JsonSerializer.Deserialize&lt;ApiResponse&lt;MarketBook&lt;ApiRunner&gt;&gt;&gt;(marketBookJson);&#10;       //Console.WriteLine($&quot;ProcessHorseMarketBooksAsync: Deserialized MarketBook API Response. Result count: {marketBookApiResponse?.Result?.Count ?? 0}.&quot;);&#10;&#10;        if (marketBookApiResponse?.Result == null || !marketBookApiResponse.Result.Any())&#10;        {&#10;           //Console.WriteLine(&quot;ProcessHorseMarketBooksAsync: No market book results found after deserialization.&quot;);&#10;            return new List&lt;RunnerFlat&gt;();&#10;        }&#10;&#10;        // Step 2: Flatten MarketBooks to RunnerFlat objects, COMBINING with catalogue data&#10;       //Console.WriteLine(&quot;ProcessHorseMarketBooksAsync: Starting to flatten market books to RunnerFlat.&quot;);&#10;        var flattenedMarketBooks = marketBookApiResponse.Result&#10;            .Where(book =&gt; !string.IsNullOrEmpty(book.MarketId))&#10;            .Select(book =&gt; new MarketBook&lt;RunnerFlat&gt;&#10;            {&#10;                MarketId = book.MarketId,&#10;                Status = book.Status,&#10;                BetDelay = book.BetDelay,&#10;                LastMatchTime = book.LastMatchTime,&#10;                TotalMatched = book.TotalMatched,&#10;                Runners = book.Runners?.Select(apiRunner =&gt;&#10;                {&#10;                    // Attempt to get the RunnerDescription from the pre-populated lookup&#10;                    RunnerDescription? runnerDescriptionFromCatalogue = null;&#10;                    bool foundInLookup = _runnerDescriptionsLookup.TryGetValue(apiRunner.SelectionId, out runnerDescriptionFromCatalogue);&#10;&#10;                    // Safely get metadata and runner name from the catalogue description&#10;                    // If not found in catalogue, metadata and runnerName will remain null.&#10;                    var metadata = runnerDescriptionFromCatalogue?.Metadata ?? new RunnerMetadata(); // If description is null, default to empty metadata&#10;                    var runnerName = runnerDescriptionFromCatalogue?.RunnerName;&#10;&#10;                    // *** NEW LOGGING HERE ***&#10;                   //Console.WriteLine($&quot;  Processing Runner: {apiRunner.SelectionId}. Found in lookup: {foundInLookup}&quot;);&#10;                    if (foundInLookup)&#10;                    {&#10;                       //Console.WriteLine($&quot;    Catalogue Data: Name='{runnerName ?? &quot;NULL&quot;}', Form='{metadata.Form ?? &quot;NULL&quot;}', JockeyClaim='{metadata.JockeyClaim ?? &quot;NULL&quot;}'&quot;);&#10;                    }&#10;                    else&#10;                    {&#10;                       //Console.WriteLine($&quot;    WARNING: No catalogue description found for SelectionId: {apiRunner.SelectionId}. Metadata will be null.&quot;);&#10;                    }&#10;                    // *** END NEW LOGGING ***&#10;&#10;                    return new RunnerFlat&#10;                    {&#10;                        SelectionId = apiRunner.SelectionId,&#10;                        Handicap = apiRunner.Handicap,&#10;                        Status = apiRunner.Status, // From MarketBook API&#10;                        LastPriceTraded = apiRunner.LastPriceTraded, // From MarketBook API&#10;                        TotalMatched = apiRunner.TotalMatched, // From MarketBook API&#10;&#10;                        RunnerName = runnerName, // From Market Catalogue Description&#10;&#10;                        // Metadata fields from Market Catalogue Description&#10;                        Form = metadata.Form,&#10;                        WeightValue = metadata.WeightValue,&#10;                        StallDraw = metadata.StallDraw,&#10;                        TrainerName = metadata.TrainerName,&#10;                        OwnerName = metadata.OwnerName,&#10;                        Age = metadata.Age,&#10;                        SireName = metadata.SireName,&#10;                        DamName = metadata.DamName,&#10;                        Wearing = metadata.Wearing,&#10;                        JockeyName = metadata.JockeyName,&#10;                        JockeyClaim = metadata.JockeyClaim,&#10;                        SexType = metadata.SexType,&#10;                        DaysSinceLastRun = metadata.DaysSinceLastRun,&#10;                        SireBred = metadata.SireBred,&#10;                        DamBred = metadata.DamBred,&#10;                        DamsireName = metadata.DamsireName,&#10;                        DamsireBred = metadata.DamsireBred,&#10;                        DamsireYearBorn = metadata.DamsireYearBorn,&#10;                        SireYearBorn = metadata.SireYearBorn,&#10;                        DamYearBorn = metadata.DamYearBorn,&#10;                        AdjustedRating = metadata.AdjustedRating,&#10;                        OfficialRating = metadata.OfficialRating,&#10;                        ForecastPriceNumerator = metadata.ForecastPriceNumerator,&#10;                        ForecastPriceDenominator = metadata.ForecastPriceDenominator,&#10;                        Bred = metadata.Bred,&#10;                        ColourType = metadata.ColourType,&#10;                        WeightUnits = metadata.WeightUnits,&#10;                        ClothNumber = metadata.ClothNumber,&#10;                        ClothNumberAlpha = metadata.ClothNumberAlpha,&#10;                        ColoursDescription = metadata.ColoursDescription,&#10;                        ColoursFilename = metadata.ColoursFilename,&#10;                        MetadataRunnerId = metadata.RunnerId,&#10;                    };&#10;                }).ToList()&#10;            }).ToList();&#10;&#10;       //Console.WriteLine($&quot;ProcessHorseMarketBooksAsync: Finished flattening. Total flattened market books: {flattenedMarketBooks.Count}.&quot;);&#10;&#10;        // Step 3: Insert into Database&#10;        if (flattenedMarketBooks.Any())&#10;        {&#10;           //Console.WriteLine(&quot;--- VERIFYING flattenedMarketBooks contents before DB insertion ---&quot;);&#10;            int totalRunnersToInsert = 0;&#10;            // Iterate all flattened market books to get the total count&#10;            foreach (var marketBookFlat in flattenedMarketBooks)&#10;            {&#10;                if (marketBookFlat.Runners != null)&#10;                {&#10;                    totalRunnersToInsert += marketBookFlat.Runners.Count;&#10;                }&#10;            }&#10;&#10;            // Limit print to first 5 market books for detailed check, but report total&#10;            foreach (var marketBookFlat in flattenedMarketBooks.Take(5))&#10;            {&#10;               //Console.WriteLine($&quot;  MarketId: {marketBookFlat.MarketId}, Status: {marketBookFlat.Status}, Total Matched: {marketBookFlat.TotalMatched}&quot;);&#10;                if (marketBookFlat.Runners != null)&#10;                {&#10;                   Console.WriteLine($&quot;    Runners in this MarketBook: {marketBookFlat.Runners.Count}&quot;);&#10;                    // Print details of the first few runners to ensure data integrity&#10;                    foreach (var runnerFlat in marketBookFlat.Runners.Take(5)) // Print first 5 runners per market book&#10;                    {&#10;                       Console.WriteLine($&quot;      RunnerFlat Name: '{runnerFlat.RunnerName ?? &quot;NULL&quot;}' (SelId: {runnerFlat.SelectionId}), LPT: {runnerFlat.LastPriceTraded}&quot;);&#10;                       Console.WriteLine($&quot;        Form: '{runnerFlat.Form ?? &quot;NULL&quot;}'&quot;);&#10;                       Console.WriteLine($&quot;        JockeyClaim: '{runnerFlat.JockeyClaim ?? &quot;NULL&quot;}'&quot;);&#10;                       Console.WriteLine($&quot;        OfficialRating: '{runnerFlat.OfficialRating ?? &quot;NULL&quot;}'&quot;);&#10;                        // Add any other critical fields you're checking for &quot;nulls&quot; in the DB&#10;                    }&#10;                }&#10;            }&#10;           //Console.WriteLine($&quot;--- Total Runners to attempt inserting across all market books: {totalRunnersToInsert} ---&quot;);&#10;           //Console.WriteLine(&quot;ProcessHorseMarketBooksAsync: Calling InsertHorseMarketBooksIntoDatabase...&quot;);&#10;&#10;            await _marketBookDb.InsertHorseMarketBooksIntoDatabase(flattenedMarketBooks);&#10;&#10;           //Console.WriteLine(&quot;ProcessHorseMarketBooksAsync: InsertHorseMarketBooksIntoDatabase call completed.&quot;);&#10;        }&#10;        else&#10;        {&#10;           //Console.WriteLine(&quot;ProcessHorseMarketBooksAsync: No flattened market books to insert into the database.&quot;);&#10;        }&#10;&#10;        // Step 4: Return flattened runners&#10;        var allFlattenedRunners = flattenedMarketBooks.SelectMany(marketBook =&gt; marketBook.Runners).ToList();&#10;       //Console.WriteLine($&quot;ProcessHorseMarketBooksAsync: Returning {allFlattenedRunners.Count} total RunnerFlat objects.&quot;);&#10;        return allFlattenedRunners;&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;       //Console.WriteLine($&quot;ProcessHorseMarketBooksAsync ERROR: {ex.Message}&quot;);&#10;       //Console.WriteLine($&quot;Stack Trace: {ex.StackTrace}&quot;);&#10;        if (ex.InnerException != null)&#10;        {&#10;           //Console.WriteLine($&quot;Inner Exception: {ex.InnerException.Message}&quot;);&#10;           //Console.WriteLine($&quot;Inner Exception Stack Trace: {ex.InnerException.StackTrace}&quot;);&#10;        }&#10;        return new List&lt;RunnerFlat&gt;();&#10;    }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Text.Json;&#10;using System.Text.Json.Serialization; // Required for [JsonPropertyName]&#10;using System.Threading.Tasks; // Required for async/await&#10;&#10;// Assuming these namespaces are correct for your models and services&#10;using Betfair.Data; // For ListMarketCatalogueDb, MarketBookDb&#10;using Betfair.Models; // For ApiResponse&#10;using Betfair.Models.Market; // For MarketBook, MarketCatalogue&#10;using Betfair.Models.Runner; // For ApiRunner, RunnerDescription, RunnerFlat, RunnerMetadata&#10;using Betfair.Services; // For IMarketApiService, IEventService&#10;&#10;namespace Betfair.AutomationServices&#10;{&#10;    // --- START: Models (Ensuring they are correctly defined with JsonPropertyName) ---&#10;    // You should have these in their respective files (e.g., Models/Runner/RunnerFlat.cs, Models/Runner/RunnerMetadata.cs)&#10;    // I'm including them here for completeness based on our discussion, but put them in their proper files.&#10;&#10;    public class HorseRacingAutomationService&#10;    {&#10;        private readonly IMarketApiService _marketApiService;&#10;        private readonly ListMarketCatalogueDb _listMarketCatalogueDb;&#10;        private readonly MarketBookDb _marketBookDb;&#10;        private readonly IEventService _eventService;&#10;&#10;        // New field to store runner descriptions for lookup&#10;        private Dictionary&lt;long, RunnerDescription&gt; _runnerDescriptionsLookup;&#10;        private Dictionary&lt;string, MarketCatalogue&gt; _marketCatalogueLookup = new();&#10;&#10;        public HorseRacingAutomationService(&#10;            IMarketApiService marketApiService,&#10;            ListMarketCatalogueDb listMarketCatalogueDb,&#10;            MarketBookDb marketBookDb,&#10;            IEventService eventService)&#10;        {&#10;            _marketApiService = marketApiService;&#10;            _listMarketCatalogueDb = listMarketCatalogueDb;&#10;            _marketBookDb = marketBookDb;&#10;            _eventService = eventService;&#10;&#10;            // Initialize the lookup dictionary&#10;            _runnerDescriptionsLookup = new Dictionary&lt;long, RunnerDescription&gt;();&#10;            _marketCatalogueLookup = new Dictionary&lt;string, MarketCatalogue&gt;();&#10;        }&#10;&#10;        // Method 1: GetAndProcessHorseRacingMarketCataloguesAsync (fetches descriptions)&#10;        public async Task&lt;List&lt;MarketCatalogue&gt;&gt; GetAndProcessHorseRacingMarketCataloguesAsync(string eventId = null)&#10;        {&#10;            var today = DateTime.UtcNow.Date;&#10;&#10;            //Console.WriteLine($&quot;--- GetAndProcessHorseRacingMarketCataloguesAsync: Fetching Market Catalogues for today ({today:yyyy-MM-dd}) ---&quot;);&#10;            var marketCatalogueJson = await _marketApiService.ListHorseRacingMarketCatalogueAsync(eventTypeId: &quot;7&quot;, openDate: today);&#10;&#10;            Console.WriteLine(&quot;--- Raw Market Catalogue JSON (full) ---&quot;);&#10;            Console.WriteLine(marketCatalogueJson);&#10;&#10;            //Console.WriteLine(&quot;--- Raw Market Catalogue JSON (first 500 chars) ---&quot;);&#10;            //Console.WriteLine(marketCatalogueJson.Substring(0, Math.Min(500, marketCatalogueJson.Length)));&#10;&#10;            //Console.WriteLine(&quot;--- Attempting Deserialization of Market Catalogue ---&quot;);&#10;&#10;            ApiResponse&lt;MarketCatalogue&gt; apiResponse;&#10;&#10;            try&#10;            {&#10;                // Define JsonSerializerOptions to handle case-insensitivity, ignore nulls, and allow trailing commas&#10;                var options = new JsonSerializerOptions&#10;                {&#10;                    PropertyNameCaseInsensitive = true,  // Handle case-insensitive property names&#10;                    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull, // Ignore nulls&#10;                    AllowTrailingCommas = true  // Allow trailing commas in JSON&#10;                };&#10;&#10;                // Deserialize the overall API response wrapper with the specified options&#10;                apiResponse = JsonSerializer.Deserialize&lt;ApiResponse&lt;MarketCatalogue&gt;&gt;(marketCatalogueJson, options);&#10;&#10;               //Console.WriteLine($&quot;Deserialization successful. Market Catalogue API Response Result property is {(apiResponse?.Result != null ? &quot;not null&quot; : &quot;null&quot;)}.&quot;);&#10;&#10;                if (apiResponse?.Result != null)&#10;                {&#10;                   //Console.WriteLine($&quot;Market catalogues received (apiResponse.Result.Count): {apiResponse.Result.Count}&quot;);&#10;                }&#10;            }&#10;            catch (JsonException ex)&#10;            {&#10;                // Handle JSON parsing errors (log, rethrow, etc.)&#10;               //Console.WriteLine($&quot;JSON Deserialization ERROR for Market Catalogue: {ex.Message}&quot;);&#10;               //Console.WriteLine($&quot;JSON Path: {ex.Path}, LineNumber: {ex.LineNumber}, BytePositionInLine: {ex.BytePositionInLine}&quot;);&#10;                return new List&lt;MarketCatalogue&gt;(); // Return empty list on deserialization error&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                // Handle other types of exceptions&#10;               //Console.WriteLine($&quot;General Deserialization ERROR for Market Catalogue: {ex.Message}&quot;);&#10;                return new List&lt;MarketCatalogue&gt;(); // Return empty list on other errors&#10;            }&#10;&#10;            var marketCatalogues = apiResponse?.Result ?? new List&lt;MarketCatalogue&gt;();&#10;&#10;            _marketCatalogueLookup = marketCatalogues&#10;                .Where(mc =&gt; !string.IsNullOrEmpty(mc.MarketId))&#10;                .ToDictionary(mc =&gt; mc.MarketId, mc =&gt; mc);&#10;&#10;           //Console.WriteLine($&quot;Final processed market catalogues count: {marketCatalogues.Count}&quot;);&#10;&#10;            if (marketCatalogues.Any())&#10;            {&#10;               //Console.WriteLine(&quot;--- Verifying Market Catalogue Contents (Post-Deserialization) ---&quot;);&#10;                foreach (var market in marketCatalogues.Take(2)) // Print details for first 2 markets&#10;                {&#10;                   //Console.WriteLine($&quot;\nMarket Id: {market.MarketId}, Market Name: {market.MarketName}, Event: {market.Event?.Name}&quot;);&#10;&#10;                    if (market.Runners != null)&#10;                    {&#10;                       //Console.WriteLine($&quot;  Runners in this Market: {market.Runners.Count}&quot;);&#10;                        foreach (var runnerDescription in market.Runners.Take(3)) // Print first 3 runners per market&#10;                        {&#10;                            var metadata = runnerDescription.Metadata;&#10;                           //Console.WriteLine($&quot;    Runner Name: {runnerDescription.RunnerName}&quot;);&#10;                            if (metadata != null)&#10;                            {&#10;                                // This output should now show actual values, confirming Metadata is populated&#10;                               //Console.WriteLine($&quot;      Form: '{metadata.Form ?? &quot;NULL&quot;}'&quot;);&#10;                               //Console.WriteLine($&quot;      SireName: '{metadata.SireName ?? &quot;NULL&quot;}'&quot;);&#10;                               //Console.WriteLine($&quot;      Bred: '{metadata.Bred ?? &quot;NULL&quot;}'&quot;);&#10;                               //Console.WriteLine($&quot;      JockeyClaim: '{metadata.JockeyClaim ?? &quot;NULL&quot;}'&quot;); // Check nulls here&#10;                               //Console.WriteLine($&quot;      OfficialRating: '{metadata.OfficialRating ?? &quot;NULL&quot;}'&quot;); // Check nulls here&#10;                            }&#10;                            else&#10;                            {&#10;                               //Console.WriteLine($&quot;      No Metadata available for Runner: {runnerDescription.RunnerName}&quot;);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;               //Console.WriteLine(&quot;--- Finished Market Catalogue Content Verification ---&quot;);&#10;&#10;                // Populate the lookup dictionary after successful catalogue retrieval&#10;                PopulateRunnerDescriptionsLookup(marketCatalogues);&#10;            }&#10;            else&#10;            {&#10;               //Console.WriteLine(&quot;No market catalogues found.&quot;);&#10;            }&#10;            return marketCatalogues;&#10;        }&#10;&#10;        // Method to populate the lookup dictionary (called internally)&#10;        public void PopulateRunnerDescriptionsLookup(List&lt;MarketCatalogue&gt; marketCatalogues)&#10;        {&#10;            _runnerDescriptionsLookup.Clear(); // Clear any previous data&#10;&#10;            foreach (var marketCatalogue in marketCatalogues)&#10;            {&#10;                if (marketCatalogue.Runners != null)&#10;                {&#10;                    foreach (var runnerDescription in marketCatalogue.Runners)&#10;                    {&#10;                        // Log the metadata for debugging purposes&#10;                        Console.WriteLine($&quot;Runner SelectionId: {runnerDescription.SelectionId}, OwnerName: {runnerDescription.Metadata?.OwnerName}&quot;);&#10;&#10;                        // Use SelectionId as the key for lookup&#10;                        if (!_runnerDescriptionsLookup.ContainsKey(runnerDescription.SelectionId))&#10;                        {&#10;                            _runnerDescriptionsLookup.Add(runnerDescription.SelectionId, runnerDescription);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            Console.WriteLine($&quot;Populated RunnerDescriptionsLookup with {_runnerDescriptionsLookup.Count} unique runners.&quot;);&#10;        }&#10;&#10;&#10;        // Method 2: ProcessHorseMarketBooksAsync (fetches prices/status and combines with descriptions)&#10;       // Inside HorseRacingAutomationService.cs&#10;public async Task&lt;List&lt;RunnerFlat&gt;&gt; ProcessHorseMarketBooksAsync(List&lt;string&gt; marketIds)&#10;{&#10;   //Console.WriteLine($&quot;--- Starting ProcessHorseMarketBooksAsync for {marketIds.Count} market IDs ---&quot;);&#10;&#10;    if (marketIds == null || !marketIds.Any())&#10;    {&#10;       //Console.WriteLine(&quot;ProcessHorseMarketBooksAsync: No market IDs provided or list is null.&quot;);&#10;        return new List&lt;RunnerFlat&gt;();&#10;    }&#10;&#10;    // Important: Check if lookup data is available&#10;    if (!_runnerDescriptionsLookup.Any())&#10;    {&#10;       //Console.WriteLine(&quot;ProcessHorseMarketBooksAsync: Runner descriptions lookup is empty. Ensure GetAndProcessHorseRacingMarketCataloguesAsync was called and populated it.&quot;);&#10;        // This is a critical warning. If the lookup is empty, all metadata will be null.&#10;        // You might want to throw an exception or return an empty list here if having metadata is mandatory.&#10;    }&#10;    else&#10;    {&#10;       //Console.WriteLine($&quot;ProcessHorseMarketBooksAsync: Runner descriptions lookup contains {_runnerDescriptionsLookup.Count} unique runners.&quot;);&#10;    }&#10;&#10;&#10;    try&#10;    {&#10;        // Step 1: Fetch and deserialize MarketBook JSON&#10;       //Console.WriteLine($&quot;ProcessHorseMarketBooksAsync: Calling ListMarketBookAsync for {marketIds.Count} market IDs.&quot;);&#10;        var marketBookJson = await _marketApiService.ListMarketBookAsync(marketIds);&#10;       //Console.WriteLine($&quot;ProcessHorseMarketBooksAsync: Received MarketBook JSON. Length: {marketBookJson?.Length ?? 0}.&quot;);&#10;&#10;        // Print a sample of the MarketBook JSON&#10;       //Console.WriteLine(&quot;--- MarketBook JSON Sample (first 500 chars) ---&quot;);&#10;       //Console.WriteLine(marketBookJson?.Substring(0, Math.Min(500, marketBookJson.Length)) ?? &quot;NULL JSON received&quot;);&#10;       //Console.WriteLine(&quot;---------------------------------------------&quot;);&#10;&#10;&#10;        var marketBookApiResponse = JsonSerializer.Deserialize&lt;ApiResponse&lt;MarketBook&lt;ApiRunner&gt;&gt;&gt;(marketBookJson);&#10;       //Console.WriteLine($&quot;ProcessHorseMarketBooksAsync: Deserialized MarketBook API Response. Result count: {marketBookApiResponse?.Result?.Count ?? 0}.&quot;);&#10;&#10;        if (marketBookApiResponse?.Result == null || !marketBookApiResponse.Result.Any())&#10;        {&#10;           //Console.WriteLine(&quot;ProcessHorseMarketBooksAsync: No market book results found after deserialization.&quot;);&#10;            return new List&lt;RunnerFlat&gt;();&#10;        }&#10;&#10;        // Step 2: Flatten MarketBooks to RunnerFlat objects, COMBINING with catalogue data&#10;       //Console.WriteLine(&quot;ProcessHorseMarketBooksAsync: Starting to flatten market books to RunnerFlat.&quot;);&#10;        var flattenedMarketBooks = marketBookApiResponse.Result&#10;            .Where(book =&gt; !string.IsNullOrEmpty(book.MarketId))&#10;            .Select(book =&gt; new MarketBook&lt;RunnerFlat&gt;&#10;            {&#10;                MarketId = book.MarketId,&#10;                Status = book.Status,&#10;                BetDelay = book.BetDelay,&#10;                LastMatchTime = book.LastMatchTime,&#10;                TotalMatched = book.TotalMatched,&#10;                Runners = book.Runners?.Select(apiRunner =&gt;&#10;                {&#10;                    // Attempt to get the RunnerDescription from the pre-populated lookup&#10;                    RunnerDescription? runnerDescriptionFromCatalogue = null;&#10;                    bool foundInLookup = _runnerDescriptionsLookup.TryGetValue(apiRunner.SelectionId, out runnerDescriptionFromCatalogue);&#10;&#10;                    // Safely get metadata and runner name from the catalogue description&#10;                    // If not found in catalogue, metadata and runnerName will remain null.&#10;                    var metadata = runnerDescriptionFromCatalogue?.Metadata ?? new RunnerMetadata(); // If description is null, default to empty metadata&#10;                    var runnerName = runnerDescriptionFromCatalogue?.RunnerName;&#10;&#10;                    // *** NEW LOGGING HERE ***&#10;                   //Console.WriteLine($&quot;  Processing Runner: {apiRunner.SelectionId}. Found in lookup: {foundInLookup}&quot;);&#10;                    if (foundInLookup)&#10;                    {&#10;                       //Console.WriteLine($&quot;    Catalogue Data: Name='{runnerName ?? &quot;NULL&quot;}', Form='{metadata.Form ?? &quot;NULL&quot;}', JockeyClaim='{metadata.JockeyClaim ?? &quot;NULL&quot;}'&quot;);&#10;                    }&#10;                    else&#10;                    {&#10;                       //Console.WriteLine($&quot;    WARNING: No catalogue description found for SelectionId: {apiRunner.SelectionId}. Metadata will be null.&quot;);&#10;                    }&#10;                    // *** END NEW LOGGING ***&#10;&#10;                    return new RunnerFlat&#10;                    {&#10;                        SelectionId = apiRunner.SelectionId,&#10;                        Handicap = apiRunner.Handicap,&#10;                        Status = apiRunner.Status, // From MarketBook API&#10;                        LastPriceTraded = apiRunner.LastPriceTraded, // From MarketBook API&#10;                        TotalMatched = apiRunner.TotalMatched, // From MarketBook API&#10;&#10;                        RunnerName = runnerName, // From Market Catalogue Description&#10;&#10;                        // Metadata fields from Market Catalogue Description&#10;                        Form = metadata.Form,&#10;                        WeightValue = metadata.WeightValue,&#10;                        StallDraw = metadata.StallDraw,&#10;                        TrainerName = metadata.TrainerName,&#10;                        OwnerName = metadata.OwnerName,&#10;                        Age = metadata.Age,&#10;                        SireName = metadata.SireName,&#10;                        DamName = metadata.DamName,&#10;                        Wearing = metadata.Wearing,&#10;                        JockeyName = metadata.JockeyName,&#10;                        JockeyClaim = metadata.JockeyClaim,&#10;                        SexType = metadata.SexType,&#10;                        DaysSinceLastRun = metadata.DaysSinceLastRun,&#10;                        SireBred = metadata.SireBred,&#10;                        DamBred = metadata.DamBred,&#10;                        DamsireName = metadata.DamsireName,&#10;                        DamsireBred = metadata.DamsireBred,&#10;                        DamsireYearBorn = metadata.DamsireYearBorn,&#10;                        SireYearBorn = metadata.SireYearBorn,&#10;                        DamYearBorn = metadata.DamYearBorn,&#10;                        AdjustedRating = metadata.AdjustedRating,&#10;                        OfficialRating = metadata.OfficialRating,&#10;                        ForecastPriceNumerator = metadata.ForecastPriceNumerator,&#10;                        ForecastPriceDenominator = metadata.ForecastPriceDenominator,&#10;                        Bred = metadata.Bred,&#10;                        ColourType = metadata.ColourType,&#10;                        WeightUnits = metadata.WeightUnits,&#10;                        ClothNumber = metadata.ClothNumber,&#10;                        ClothNumberAlpha = metadata.ClothNumberAlpha,&#10;                        ColoursDescription = metadata.ColoursDescription,&#10;                        ColoursFilename = metadata.ColoursFilename,&#10;                        MetadataRunnerId = metadata.RunnerId,&#10;                    };&#10;                }).ToList()&#10;            }).ToList();&#10;&#10;       //Console.WriteLine($&quot;ProcessHorseMarketBooksAsync: Finished flattening. Total flattened market books: {flattenedMarketBooks.Count}.&quot;);&#10;&#10;        // Step 3: Insert into Database&#10;        if (flattenedMarketBooks.Any())&#10;        {&#10;           //Console.WriteLine(&quot;--- VERIFYING flattenedMarketBooks contents before DB insertion ---&quot;);&#10;            int totalRunnersToInsert = 0;&#10;            // Iterate all flattened market books to get the total count&#10;            foreach (var marketBookFlat in flattenedMarketBooks)&#10;            {&#10;                if (marketBookFlat.Runners != null)&#10;                {&#10;                    totalRunnersToInsert += marketBookFlat.Runners.Count;&#10;                }&#10;            }&#10;&#10;            // Limit print to first 5 market books for detailed check, but report total&#10;            foreach (var marketBookFlat in flattenedMarketBooks.Take(5))&#10;            {&#10;               //Console.WriteLine($&quot;  MarketId: {marketBookFlat.MarketId}, Status: {marketBookFlat.Status}, Total Matched: {marketBookFlat.TotalMatched}&quot;);&#10;                if (marketBookFlat.Runners != null)&#10;                {&#10;                   Console.WriteLine($&quot;    Runners in this MarketBook: {marketBookFlat.Runners.Count}&quot;);&#10;                    // Print details of the first few runners to ensure data integrity&#10;                    foreach (var runnerFlat in marketBookFlat.Runners.Take(5)) // Print first 5 runners per market book&#10;                    {&#10;                       Console.WriteLine($&quot;      RunnerFlat Name: '{runnerFlat.RunnerName ?? &quot;NULL&quot;}' (SelId: {runnerFlat.SelectionId}), LPT: {runnerFlat.LastPriceTraded}&quot;);&#10;                       Console.WriteLine($&quot;        OwnerName: '{runnerFlat.OwnerName ?? &quot;NULL&quot;}'&quot;);&#10;                       Console.WriteLine($&quot;        Form: '{runnerFlat.Form ?? &quot;NULL&quot;}'&quot;);&#10;                       Console.WriteLine($&quot;        JockeyClaim: '{runnerFlat.JockeyClaim ?? &quot;NULL&quot;}'&quot;);&#10;                       Console.WriteLine($&quot;        OfficialRating: '{runnerFlat.OfficialRating ?? &quot;NULL&quot;}'&quot;);&#10;                        // Add any other critical fields you're checking for &quot;nulls&quot; in the DB&#10;                    }&#10;                }&#10;            }&#10;           //Console.WriteLine($&quot;--- Total Runners to attempt inserting across all market books: {totalRunnersToInsert} ---&quot;);&#10;           //Console.WriteLine(&quot;ProcessHorseMarketBooksAsync: Calling InsertHorseMarketBooksIntoDatabase...&quot;);&#10;&#10;            await _marketBookDb.InsertHorseMarketBooksIntoDatabase(flattenedMarketBooks);&#10;&#10;           //Console.WriteLine(&quot;ProcessHorseMarketBooksAsync: InsertHorseMarketBooksIntoDatabase call completed.&quot;);&#10;        }&#10;        else&#10;        {&#10;           //Console.WriteLine(&quot;ProcessHorseMarketBooksAsync: No flattened market books to insert into the database.&quot;);&#10;        }&#10;&#10;        // Step 4: Return flattened runners&#10;        var allFlattenedRunners = flattenedMarketBooks.SelectMany(marketBook =&gt; marketBook.Runners).ToList();&#10;       //Console.WriteLine($&quot;ProcessHorseMarketBooksAsync: Returning {allFlattenedRunners.Count} total RunnerFlat objects.&quot;);&#10;        return allFlattenedRunners;&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;       //Console.WriteLine($&quot;ProcessHorseMarketBooksAsync ERROR: {ex.Message}&quot;);&#10;       //Console.WriteLine($&quot;Stack Trace: {ex.StackTrace}&quot;);&#10;        if (ex.InnerException != null)&#10;        {&#10;           //Console.WriteLine($&quot;Inner Exception: {ex.InnerException.Message}&quot;);&#10;           //Console.WriteLine($&quot;Inner Exception Stack Trace: {ex.InnerException.StackTrace}&quot;);&#10;        }&#10;        return new List&lt;RunnerFlat&gt;();&#10;    }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Betfair/Data/MarketBookDb.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Betfair/Data/MarketBookDb.cs" />
              <option name="originalContent" value="using System.Text.Json;&#10;using Microsoft.Data.Sqlite;&#10;using Betfair.Models.Market;&#10;using Betfair.Models.Runner;&#10;using Dapper;&#10;&#10;namespace Betfair.Data;&#10;&#10;public class MarketInfo&#10;{&#10;    public string? MarketName { get; set; }&#10;    public string? EventName { get; set; }&#10;&#10;    public void Deconstruct(out string? marketName, out string? eventName)&#10;    {&#10;        marketName = MarketName;&#10;        eventName = EventName;&#10;    }&#10;}&#10;&#10;public class MarketBookDb&#10;{&#10;    private readonly string _connectionString;&#10;&#10;    public MarketBookDb(string connectionString)&#10;    {&#10;        _connectionString = connectionString;&#10;        try&#10;        {&#10;            VerifyHorseMarketBookSchema();&#10;        }&#10;        catch (Exception)&#10;        {&#10;            // Log or handle initialization errors if necessary&#10;        }&#10;    }&#10;&#10;    private void VerifyHorseMarketBookSchema()&#10;    {&#10;        using var connection = new SqliteConnection(_connectionString);&#10;        connection.Open();&#10;        var cmd = connection.CreateCommand();&#10;        cmd.CommandText = &quot;PRAGMA table_info(HorseMarketBook);&quot;;&#10;&#10;        using var reader = cmd.ExecuteReader();&#10;        while (reader.Read())&#10;        {&#10;            string colName = reader.GetString(1);&#10;            if (colName.Equals(&quot;DAM_YEAR_BORN&quot;, StringComparison.OrdinalIgnoreCase))&#10;            {&#10;                // Column exists, no further action needed&#10;            }&#10;        }&#10;    }&#10;    public async Task InsertHorseMarketBooksIntoDatabase(List&lt;MarketBook&lt;RunnerFlat&gt;&gt; marketBooks)&#10;{&#10;    if (marketBooks == null || !marketBooks.Any())&#10;    {&#10;        return;&#10;    }&#10;&#10;    using var connection = new SqliteConnection(_connectionString);&#10;    await connection.OpenAsync();&#10;    using var transaction = await connection.BeginTransactionAsync();&#10;&#10;    int successfulRunnerInserts = 0;&#10;    int skippedMarketBooks = 0;&#10;&#10;    try&#10;    {&#10;        foreach (var marketBook in marketBooks)&#10;        {&#10;            string marketId = marketBook.MarketId;&#10;&#10;            if (string.IsNullOrEmpty(marketId))&#10;            {&#10;                skippedMarketBooks++;&#10;                continue;&#10;            }&#10;&#10;            var existingMarket = await connection.ExecuteScalarAsync&lt;int&gt;(&#10;                &quot;SELECT COUNT(1) FROM HorseMarketBook WHERE MarketId = @MarketId&quot;,&#10;                new { MarketId = marketId });&#10;&#10;            if (existingMarket &gt; 0)&#10;            {&#10;                skippedMarketBooks++;&#10;                continue;&#10;            }&#10;&#10;            var marketInfo = await GetMarketNameAndEventNameByMarketId(connection, marketId);&#10;            string marketName = marketInfo?.MarketName ?? &quot;Unknown&quot;;&#10;&#10;            foreach (var runner in marketBook.Runners)&#10;            {&#10;                if (runner.SelectionId == null)&#10;                {&#10;                    continue;&#10;                }&#10;&#10;                // Debug logging for null fields&#10;                Console.WriteLine($&quot;Runner Data: DAM_YEAR_BORN={runner.DamYearBorn}, OWNER_NAME={runner.OwnerName}, WEARING={runner.Wearing}, JOCKEY_CLAIM={runner.JockeyClaim}, DAMSIRE_YEAR_BORN={runner.DamsireYearBorn}, OFFICIAL_RATING={runner.OfficialRating}&quot;);&#10;&#10;                var paramValues = new Dictionary&lt;string, object&gt;&#10;                {&#10;                    [&quot;MarketId&quot;] = marketId,&#10;                    [&quot;MarketName&quot;] = marketInfo?.MarketName ?? &quot;Unknown&quot;,&#10;                    [&quot;EventName&quot;] = marketInfo?.EventName ?? &quot;Unknown&quot;,&#10;                    [&quot;SelectionId&quot;] = runner.SelectionId,&#10;                    [&quot;RunnerName&quot;] = runner.RunnerName ?? &quot;Unknown&quot;,&#10;                    [&quot;Status&quot;] = runner.Status,&#10;                    [&quot;SIRE_NAME&quot;] = runner.SireName,&#10;                    [&quot;CLOTH_NUMBER_ALPHA&quot;] = runner.ClothNumberAlpha,&#10;                    [&quot;OFFICIAL_RATING&quot;] = ParseNullableDouble(runner.OfficialRating) ?? 0.0,&#10;                    [&quot;COLOURS_DESCRIPTION&quot;] = runner.ColoursDescription,&#10;                    [&quot;COLOURS_FILENAME&quot;] = runner.ColoursFilename,&#10;                    [&quot;FORECASTPRICE_DENOMINATOR&quot;] = ParseNullableInt(runner.ForecastPriceDenominator) ?? 0,&#10;                    [&quot;DAMSIRE_NAME&quot;] = runner.DamsireName,&#10;                    [&quot;WEIGHT_VALUE&quot;] = ParseNullableDouble(runner.WeightValue) ?? 0.0,&#10;                    [&quot;SEX_TYPE&quot;] = runner.SexType,&#10;                    [&quot;DAYS_SINCE_LAST_RUN&quot;] = ParseNullableInt(runner.DaysSinceLastRun) ?? 0,&#10;                    [&quot;WEARING&quot;] = runner.Wearing,&#10;                    [&quot;OWNER_NAME&quot;] = runner.OwnerName,&#10;                    [&quot;OWNER_NAME&quot;] = runner.OwnerName,&#10;                    [&quot;DAM_YEAR_BORN&quot;] = ParseNullableInt(runner.DamYearBorn) ?? 0,&#10;                    [&quot;SIRE_BRED&quot;] = runner.SireBred,&#10;                    [&quot;JOCKEY_NAME&quot;] = runner.JockeyName,&#10;                    [&quot;DAM_BRED&quot;] = runner.DamBred,&#10;                    [&quot;ADJUSTED_RATING&quot;] = ParseNullableDouble(runner.AdjustedRating) ?? 0.0,&#10;                    [&quot;CLOTH_NUMBER&quot;] = runner.ClothNumber,&#10;                    [&quot;SIRE_YEAR_BORN&quot;] = ParseNullableInt(runner.SireYearBorn) ?? 0,&#10;                    [&quot;TRAINER_NAME&quot;] = runner.TrainerName,&#10;                    [&quot;COLOUR_TYPE&quot;] = runner.ColourType,&#10;                    [&quot;AGE&quot;] = ParseNullableInt(runner.Age) ?? 0,&#10;                    [&quot;DAMSIRE_BRED&quot;] = runner.DamsireBred,&#10;                    [&quot;JOCKEY_CLAIM&quot;] = ParseNullableDouble(runner.JockeyClaim) ?? 0.0,&#10;                    [&quot;FORM&quot;] = runner.Form ?? &quot;N/A&quot;,&#10;                    [&quot;FORECASTPRICE_NUMERATOR&quot;] = ParseNullableInt(runner.ForecastPriceNumerator) ?? 0,&#10;                    [&quot;BRED&quot;] = runner.Bred,&#10;                    [&quot;DAM_NAME&quot;] = runner.DamName,&#10;                    [&quot;DAMSIRE_YEAR_BORN&quot;] = ParseNullableInt(runner.DamsireYearBorn) ?? 0,&#10;                    [&quot;STALL_DRAW&quot;] = ParseNullableInt(runner.StallDraw) ?? 0,&#10;                    [&quot;WEIGHT_UNITS&quot;] = runner.WeightUnits&#10;                };&#10;&#10;                using var command = connection.CreateCommand();&#10;                command.CommandText = @&quot;&#10;                INSERT INTO HorseMarketBook (&#10;                    MarketId, MarketName, EventName, SelectionId, RUNNER_NAME, Status,&#10;                    SIRE_NAME, STALL_DRAW, DAMSIRE_NAME, FORM, WEIGHT_VALUE,&#10;                    SEX_TYPE, DAYS_SINCE_LAST_RUN, WEARING, OWNER_NAME, DAM_YEAR_BORN,&#10;                    SIRE_BRED, JOCKEY_NAME, DAM_BRED, CLOTH_NUMBER, SIRE_YEAR_BORN,&#10;                    TRAINER_NAME, COLOUR_TYPE, AGE, DAMSIRE_BRED, JOCKEY_CLAIM,&#10;                    FORECASTPRICE_NUMERATOR, BRED, DAM_NAME, DAMSIRE_YEAR_BORN, WEIGHT_UNITS,&#10;                    CLOTH_NUMBER_ALPHA, OFFICIAL_RATING, COLOURS_DESCRIPTION, COLOURS_FILENAME,&#10;                    FORECASTPRICE_DENOMINATOR&#10;                ) VALUES (&#10;                    $MarketId, $MarketName, $EventName, $SelectionId, $RunnerName, $Status,&#10;                    $SIRE_NAME, $STALL_DRAW, $DAMSIRE_NAME, $FORM, $WEIGHT_VALUE,&#10;                    $SEX_TYPE, $DAYS_SINCE_LAST_RUN, $WEARING, $OWNER_NAME, $DAM_YEAR_BORN,&#10;                    $SIRE_BRED, $JOCKEY_NAME, $DAM_BRED, $CLOTH_NUMBER, $SIRE_YEAR_BORN,&#10;                    $TRAINER_NAME, $COLOUR_TYPE, $AGE, $DAMSIRE_BRED, $JOCKEY_CLAIM,&#10;                    $FORECASTPRICE_NUMERATOR, $BRED, $DAM_NAME, $DAMSIRE_YEAR_BORN, $WEIGHT_UNITS,&#10;                    $CLOTH_NUMBER_ALPHA, $OFFICIAL_RATING, $COLOURS_DESCRIPTION, $COLOURS_FILENAME,&#10;                    $FORECASTPRICE_DENOMINATOR&#10;                )&quot;;&#10;&#10;                foreach (var kvp in paramValues)&#10;                {&#10;                    command.Parameters.AddWithValue($&quot;${kvp.Key}&quot;, kvp.Value ?? (object)DBNull.Value);&#10;                }&#10;&#10;                await command.ExecuteNonQueryAsync();&#10;                successfulRunnerInserts++;&#10;            }&#10;        }&#10;&#10;        await transaction.CommitAsync();&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        await transaction.RollbackAsync();&#10;    }&#10;}&#10;&#10;    public async Task InsertMarketBooksIntoDatabase(List&lt;MarketBook&lt;ApiRunner&gt;&gt; marketBooks)&#10;    {&#10;        using var connection = new SqliteConnection(_connectionString);&#10;        await connection.OpenAsync();&#10;       //Console.WriteLine(new string('*', 215));&#10;&#10;        using var transaction = await connection.BeginTransactionAsync();&#10;&#10;        await DeleteExistingData(connection, new List&lt;string&gt; { &quot;MarketBookBackPrices&quot;, &quot;MarketBookLayPrices&quot; });&#10;        await ResetAutoIncrementCounters(connection, new List&lt;string&gt; { &quot;MarketBookBackPrices&quot;, &quot;MarketBookLayPrices&quot; });&#10;&#10;        try&#10;        {&#10;            foreach (var marketBook in marketBooks)&#10;            {&#10;                string marketId = marketBook.MarketId;&#10;&#10;                foreach (var runner in marketBook.Runners)&#10;                {&#10;                    if (runner.Exchange != null)&#10;                    {&#10;                        foreach (var back in runner.Exchange.AvailableToBack)&#10;                        {&#10;                            if (await IsDataExist(connection, &quot;MarketBookBackPrices&quot;, marketId, runner.SelectionId, back.Price))&#10;                            {&#10;                               //Console.WriteLine($&quot;Skipping duplicate Back bet data for Runner {runner.SelectionId}: Price = {back.Price}&quot;);&#10;                                continue;&#10;                            }&#10;&#10;                            using var priceCommand = connection.CreateCommand();&#10;                            priceCommand.CommandText = @&quot;&#10;                                INSERT INTO MarketBookBackPrices&#10;                                (MarketId, SelectionId, Price, Size, Status, LastPriceTraded, TotalMatched)&#10;                                VALUES&#10;                                ($MarketId, $SelectionId, $Price, $Size, $Status, $LastPriceTraded, $TotalMatched)&quot;;&#10;&#10;                            priceCommand.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Price&quot;, (double)back.Price);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Size&quot;, (double)back.Size);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$LastPriceTraded&quot;, runner.LastPriceTraded ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$TotalMatched&quot;, runner.TotalMatched ?? (object)DBNull.Value);&#10;&#10;                            await priceCommand.ExecuteNonQueryAsync();&#10;                        }&#10;&#10;                        foreach (var lay in runner.Exchange.AvailableToLay)&#10;                        {&#10;                            if (await IsDataExist(connection, &quot;MarketBookLayPrices&quot;, marketId, runner.SelectionId, lay.Price))&#10;                            {&#10;                               //Console.WriteLine($&quot;Skipping duplicate Lay bet data for Runner {runner.SelectionId}: Price = {lay.Price}&quot;);&#10;                                continue;&#10;                            }&#10;&#10;                            using var priceCommand = connection.CreateCommand();&#10;                            priceCommand.CommandText = @&quot;&#10;                                INSERT INTO MarketBookLayPrices&#10;                                (MarketId, SelectionId, Price, Size, Status, LastPriceTraded, TotalMatched)&#10;                                VALUES&#10;                                ($MarketId, $SelectionId, $Price, $Size, $Status, $LastPriceTraded, $TotalMatched)&quot;;&#10;&#10;                            priceCommand.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Price&quot;, (double)lay.Price);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Size&quot;, (double)lay.Size);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$LastPriceTraded&quot;, runner.LastPriceTraded ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$TotalMatched&quot;, runner.TotalMatched ?? (object)DBNull.Value);&#10;&#10;                            await priceCommand.ExecuteNonQueryAsync();&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            await transaction.CommitAsync();&#10;           //Console.WriteLine(&quot;Market book back/lay prices inserted successfully.&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            await transaction.RollbackAsync();&#10;           //Console.WriteLine($&quot;Error inserting market book prices: {ex.Message}&quot;);&#10;           //Console.WriteLine(ex.ToString());&#10;        }&#10;    }&#10;&#10;&#10;    public async Task InsertGreyhoundMarketBooksIntoDatabase(List&lt;MarketBook&lt;ApiRunner&gt;&gt; marketBooks)&#10;    {&#10;        using var connection = new SqliteConnection(_connectionString);&#10;        await connection.OpenAsync();&#10;        using var transaction = await connection.BeginTransactionAsync();&#10;&#10;        try&#10;        {&#10;            foreach (var marketBook in marketBooks)&#10;            {&#10;                string marketId = marketBook.MarketId;&#10;                var marketInfo = await GetMarketNameAndEventNameByMarketId(connection, marketId);&#10;&#10;                foreach (var runner in marketBook.Runners)&#10;                {&#10;                    if (runner.Exchange?.AvailableToBack != null)&#10;                    {&#10;                        foreach (var back in runner.Exchange.AvailableToBack)&#10;                        {&#10;                            using var command = connection.CreateCommand();&#10;                            command.CommandText = @&quot;&#10;                                INSERT INTO GreyhoundMarketBook&#10;                                (MarketId, MarketName, SelectionId, Status, PriceType, Price, Size)&#10;                                VALUES&#10;                                ($MarketId, $MarketName, $SelectionId, $Status, $PriceType, $Price, $Size)&quot;;&#10;&#10;                            command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$MarketName&quot;, marketInfo?.MarketName ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            command.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$PriceType&quot;, &quot;AvailableToBack&quot;);&#10;                            command.Parameters.AddWithValue(&quot;$Price&quot;, (double)back.Price);&#10;                            command.Parameters.AddWithValue(&quot;$Size&quot;, (double)back.Size);&#10;&#10;                            await command.ExecuteNonQueryAsync();&#10;                        }&#10;                    }&#10;&#10;                    if (runner.Exchange?.AvailableToLay != null)&#10;                    {&#10;                        foreach (var lay in runner.Exchange.AvailableToLay)&#10;                        {&#10;                            using var command = connection.CreateCommand();&#10;                            command.CommandText = @&quot;&#10;                                INSERT INTO GreyhoundMarketBook&#10;                                (MarketId, MarketName, SelectionId, Status, PriceType, Price, Size)&#10;                                VALUES&#10;                                ($MarketId, $MarketName, $SelectionId, $Status, $PriceType, $Price, $Size)&quot;;&#10;&#10;                            command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$MarketName&quot;, marketInfo?.MarketName ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            command.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$PriceType&quot;, &quot;AvailableToLay&quot;);&#10;                            command.Parameters.AddWithValue(&quot;$Price&quot;, (double)lay.Price);&#10;                            command.Parameters.AddWithValue(&quot;$Size&quot;, (double)lay.Size);&#10;&#10;                            await command.ExecuteNonQueryAsync();&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            await transaction.CommitAsync();&#10;            //Console.WriteLine(&quot;Greyhound market books inserted successfully.&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            await transaction.RollbackAsync();&#10;            //Console.WriteLine($&quot;Error inserting greyhound market books: {ex.Message}&quot;);&#10;            //Console.WriteLine(ex.ToString());&#10;        }&#10;    }&#10;&#10;    public async Task&lt;List&lt;HorseMarketBook&gt;&gt; GetHorseMarketBooksAsync()&#10;{&#10;    using var connection = new SqliteConnection(_connectionString);&#10;    await connection.OpenAsync();&#10;&#10;    var query = @&quot;SELECT MarketId, MarketName, EventName, SelectionId, RUNNER_NAME as RunnerName, Status, SIRE_NAME as SireName, DAMSIRE_NAME as DamsireName, TRAINER_NAME as TrainerName, AGE, WEIGHT_VALUE as WeightValue, COLOUR_TYPE as ColourType, FORM FROM HorseMarketBook&quot;;&#10;    var result = await connection.QueryAsync&lt;HorseMarketBook&gt;(query);&#10;&#10;    return result.ToList();&#10;}&#10;&#10;    private async Task&lt;MarketInfo&gt; GetMarketNameAndEventNameByMarketId(SqliteConnection connection, string marketId)&#10;    {&#10;        using var command = connection.CreateCommand();&#10;        command.CommandText = @&quot;&#10;        SELECT MarketName, EventName&#10;        FROM EventMarkets&#10;        WHERE MarketId = $MarketId&#10;        LIMIT 1&quot;;&#10;        command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId);&#10;&#10;        using var reader = await command.ExecuteReaderAsync();&#10;        if (await reader.ReadAsync())&#10;        {&#10;            return new MarketInfo&#10;            {&#10;                MarketName = reader.GetString(0),&#10;                EventName = reader.GetString(1)&#10;            };&#10;        }&#10;&#10;        Console.WriteLine($&quot;No matching MarketId found in EventMarkets for MarketId: {marketId}&quot;);&#10;        return new MarketInfo { MarketName = &quot;Unknown&quot;, EventName = &quot;Unknown&quot; };&#10;    }&#10;&#10;    private static int? ParseNullableInt(string input) =&gt;&#10;        int.TryParse(input, out var result) ? result : null;&#10;&#10;    private static double? ParseNullableDouble(string input) =&gt;&#10;        double.TryParse(input, out var result) ? result : null;&#10;&#10;    private async Task DeleteExistingData(SqliteConnection connection, List&lt;string&gt; tableNames)&#10;    {&#10;        // Method removed as per request to avoid deletion logic.&#10;    }&#10;&#10;    private async Task&lt;bool&gt; IsDataExist(SqliteConnection connection, string tableName, object marketId, object selectionId, object price)&#10;    {&#10;        using var command = connection.CreateCommand();&#10;        command.CommandText = $@&quot;&#10;        SELECT COUNT(1)&#10;        FROM {tableName}&#10;        WHERE MarketId = $MarketId&#10;        AND SelectionId = $SelectionId&#10;        AND Price = $Price&quot;;&#10;&#10;        command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId);&#10;        command.Parameters.AddWithValue(&quot;$SelectionId&quot;, selectionId);&#10;        command.Parameters.AddWithValue(&quot;$Price&quot;, price ?? (object)DBNull.Value);&#10;&#10;        var count = await command.ExecuteScalarAsync();&#10;        return (long)count &gt; 0;&#10;    }&#10;&#10;    private async Task ResetAutoIncrementCounters(SqliteConnection connection, List&lt;string&gt; tableNames)&#10;    {&#10;        foreach (var table in tableNames)&#10;        {&#10;            using var resetCommand = connection.CreateCommand();&#10;            resetCommand.CommandText = $&quot;DELETE FROM SQLITE_SEQUENCE WHERE NAME = '{table}'&quot;;&#10;            await resetCommand.ExecuteNonQueryAsync();&#10;        }&#10;    }&#10;&#10;    public async Task DeleteFinishedRacesAsync()&#10;    {&#10;        // Method removed as per request to avoid deletion logic.&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Text.Json;&#10;using Microsoft.Data.Sqlite;&#10;using Betfair.Models.Market;&#10;using Betfair.Models.Runner;&#10;using Dapper;&#10;&#10;namespace Betfair.Data;&#10;&#10;public class MarketInfo&#10;{&#10;    public string? MarketName { get; set; }&#10;    public string? EventName { get; set; }&#10;&#10;    public void Deconstruct(out string? marketName, out string? eventName)&#10;    {&#10;        marketName = MarketName;&#10;        eventName = EventName;&#10;    }&#10;}&#10;&#10;public class MarketBookDb&#10;{&#10;    private readonly string _connectionString;&#10;&#10;    public MarketBookDb(string connectionString)&#10;    {&#10;        _connectionString = connectionString;&#10;        try&#10;        {&#10;            VerifyHorseMarketBookSchema();&#10;        }&#10;        catch (Exception)&#10;        {&#10;            // Log or handle initialization errors if necessary&#10;        }&#10;    }&#10;&#10;    private void VerifyHorseMarketBookSchema()&#10;    {&#10;        using var connection = new SqliteConnection(_connectionString);&#10;        connection.Open();&#10;        var cmd = connection.CreateCommand();&#10;        cmd.CommandText = &quot;PRAGMA table_info(HorseMarketBook);&quot;;&#10;&#10;        using var reader = cmd.ExecuteReader();&#10;        while (reader.Read())&#10;        {&#10;            string colName = reader.GetString(1);&#10;            if (colName.Equals(&quot;DAM_YEAR_BORN&quot;, StringComparison.OrdinalIgnoreCase))&#10;            {&#10;                // Column exists, no further action needed&#10;            }&#10;        }&#10;    }&#10;    public async Task InsertHorseMarketBooksIntoDatabase(List&lt;MarketBook&lt;RunnerFlat&gt;&gt; marketBooks)&#10;{&#10;    if (marketBooks == null || !marketBooks.Any())&#10;    {&#10;        return;&#10;    }&#10;&#10;    using var connection = new SqliteConnection(_connectionString);&#10;    await connection.OpenAsync();&#10;    using var transaction = await connection.BeginTransactionAsync();&#10;&#10;    int successfulRunnerInserts = 0;&#10;    int skippedMarketBooks = 0;&#10;&#10;    try&#10;    {&#10;        foreach (var marketBook in marketBooks)&#10;        {&#10;            string marketId = marketBook.MarketId;&#10;&#10;            if (string.IsNullOrEmpty(marketId))&#10;            {&#10;                skippedMarketBooks++;&#10;                continue;&#10;            }&#10;&#10;            var existingMarket = await connection.ExecuteScalarAsync&lt;int&gt;(&#10;                &quot;SELECT COUNT(1) FROM HorseMarketBook WHERE MarketId = @MarketId&quot;,&#10;                new { MarketId = marketId });&#10;&#10;            if (existingMarket &gt; 0)&#10;            {&#10;                skippedMarketBooks++;&#10;                continue;&#10;            }&#10;&#10;            var marketInfo = await GetMarketNameAndEventNameByMarketId(connection, marketId);&#10;            string marketName = marketInfo?.MarketName ?? &quot;Unknown&quot;;&#10;&#10;            foreach (var runner in marketBook.Runners)&#10;            {&#10;                if (runner.SelectionId == null)&#10;                {&#10;                    continue;&#10;                }&#10;&#10;                // Log the OwnerName for debugging purposes&#10;                Console.WriteLine($&quot;Inserting Runner: SelectionId={runner.SelectionId}, OwnerName={runner.OwnerName}&quot;);&#10;&#10;                var paramValues = new Dictionary&lt;string, object&gt;&#10;                {&#10;                    [&quot;MarketId&quot;] = marketId,&#10;                    [&quot;MarketName&quot;] = marketInfo?.MarketName ?? &quot;Unknown&quot;,&#10;                    [&quot;EventName&quot;] = marketInfo?.EventName ?? &quot;Unknown&quot;,&#10;                    [&quot;SelectionId&quot;] = runner.SelectionId,&#10;                    [&quot;RunnerName&quot;] = runner.RunnerName ?? &quot;Unknown&quot;,&#10;                    [&quot;Status&quot;] = runner.Status,&#10;                    [&quot;SIRE_NAME&quot;] = runner.SireName,&#10;                    [&quot;CLOTH_NUMBER_ALPHA&quot;] = runner.ClothNumberAlpha,&#10;                    [&quot;OFFICIAL_RATING&quot;] = ParseNullableDouble(runner.OfficialRating) ?? 0.0,&#10;                    [&quot;COLOURS_DESCRIPTION&quot;] = runner.ColoursDescription,&#10;                    [&quot;COLOURS_FILENAME&quot;] = runner.ColoursFilename,&#10;                    [&quot;FORECASTPRICE_DENOMINATOR&quot;] = ParseNullableInt(runner.ForecastPriceDenominator) ?? 0,&#10;                    [&quot;DAMSIRE_NAME&quot;] = runner.DamsireName,&#10;                    [&quot;WEIGHT_VALUE&quot;] = ParseNullableDouble(runner.WeightValue) ?? 0.0,&#10;                    [&quot;SEX_TYPE&quot;] = runner.SexType,&#10;                    [&quot;DAYS_SINCE_LAST_RUN&quot;] = ParseNullableInt(runner.DaysSinceLastRun) ?? 0,&#10;                    [&quot;WEARING&quot;] = runner.Wearing,&#10;                    [&quot;OWNER_NAME&quot;] = runner.OwnerName,&#10;                    [&quot;DAM_YEAR_BORN&quot;] = ParseNullableInt(runner.DamYearBorn) ?? 0,&#10;                    [&quot;SIRE_BRED&quot;] = runner.SireBred,&#10;                    [&quot;JOCKEY_NAME&quot;] = runner.JockeyName,&#10;                    [&quot;DAM_BRED&quot;] = runner.DamBred,&#10;                    [&quot;ADJUSTED_RATING&quot;] = ParseNullableDouble(runner.AdjustedRating) ?? 0.0,&#10;                    [&quot;CLOTH_NUMBER&quot;] = runner.ClothNumber,&#10;                    [&quot;SIRE_YEAR_BORN&quot;] = ParseNullableInt(runner.SireYearBorn) ?? 0,&#10;                    [&quot;TRAINER_NAME&quot;] = runner.TrainerName,&#10;                    [&quot;COLOUR_TYPE&quot;] = runner.ColourType,&#10;                    [&quot;AGE&quot;] = ParseNullableInt(runner.Age) ?? 0,&#10;                    [&quot;DAMSIRE_BRED&quot;] = runner.DamsireBred,&#10;                    [&quot;JOCKEY_CLAIM&quot;] = ParseNullableDouble(runner.JockeyClaim) ?? 0.0,&#10;                    [&quot;FORM&quot;] = runner.Form ?? &quot;N/A&quot;,&#10;                    [&quot;FORECASTPRICE_NUMERATOR&quot;] = ParseNullableInt(runner.ForecastPriceNumerator) ?? 0,&#10;                    [&quot;BRED&quot;] = runner.Bred,&#10;                    [&quot;DAM_NAME&quot;] = runner.DamName,&#10;                    [&quot;DAMSIRE_YEAR_BORN&quot;] = ParseNullableInt(runner.DamsireYearBorn) ?? 0,&#10;                    [&quot;STALL_DRAW&quot;] = ParseNullableInt(runner.StallDraw) ?? 0,&#10;                    [&quot;WEIGHT_UNITS&quot;] = runner.WeightUnits&#10;                };&#10;&#10;                using var command = connection.CreateCommand();&#10;                command.CommandText = @&quot;&#10;                INSERT INTO HorseMarketBook (&#10;                    MarketId, MarketName, EventName, SelectionId, RUNNER_NAME, Status,&#10;                    SIRE_NAME, STALL_DRAW, DAMSIRE_NAME, FORM, WEIGHT_VALUE,&#10;                    SEX_TYPE, DAYS_SINCE_LAST_RUN, WEARING, OWNER_NAME, DAM_YEAR_BORN,&#10;                    SIRE_BRED, JOCKEY_NAME, DAM_BRED, CLOTH_NUMBER, SIRE_YEAR_BORN,&#10;                    TRAINER_NAME, COLOUR_TYPE, AGE, DAMSIRE_BRED, JOCKEY_CLAIM,&#10;                    FORECASTPRICE_NUMERATOR, BRED, DAM_NAME, DAMSIRE_YEAR_BORN, WEIGHT_UNITS,&#10;                    CLOTH_NUMBER_ALPHA, OFFICIAL_RATING, COLOURS_DESCRIPTION, COLOURS_FILENAME,&#10;                    FORECASTPRICE_DENOMINATOR&#10;                ) VALUES (&#10;                    $MarketId, $MarketName, $EventName, $SelectionId, $RunnerName, $Status,&#10;                    $SIRE_NAME, $STALL_DRAW, $DAMSIRE_NAME, $FORM, $WEIGHT_VALUE,&#10;                    $SEX_TYPE, $DAYS_SINCE_LAST_RUN, $WEARING, $OWNER_NAME, $DAM_YEAR_BORN,&#10;                    $SIRE_BRED, $JOCKEY_NAME, $DAM_BRED, $CLOTH_NUMBER, $SIRE_YEAR_BORN,&#10;                    $TRAINER_NAME, $COLOUR_TYPE, $AGE, $DAMSIRE_BRED, $JOCKEY_CLAIM,&#10;                    $FORECASTPRICE_NUMERATOR, $BRED, $DAM_NAME, $DAMSIRE_YEAR_BORN, $WEIGHT_UNITS,&#10;                    $CLOTH_NUMBER_ALPHA, $OFFICIAL_RATING, $COLOURS_DESCRIPTION, $COLOURS_FILENAME,&#10;                    $FORECASTPRICE_DENOMINATOR&#10;                )&quot;;&#10;&#10;                foreach (var kvp in paramValues)&#10;                {&#10;                    command.Parameters.AddWithValue($&quot;${kvp.Key}&quot;, kvp.Value ?? (object)DBNull.Value);&#10;                }&#10;&#10;                await command.ExecuteNonQueryAsync();&#10;                successfulRunnerInserts++;&#10;            }&#10;        }&#10;&#10;        await transaction.CommitAsync();&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        await transaction.RollbackAsync();&#10;    }&#10;}&#10;&#10;    public async Task InsertMarketBooksIntoDatabase(List&lt;MarketBook&lt;ApiRunner&gt;&gt; marketBooks)&#10;    {&#10;        using var connection = new SqliteConnection(_connectionString);&#10;        await connection.OpenAsync();&#10;       //Console.WriteLine(new string('*', 215));&#10;&#10;        using var transaction = await connection.BeginTransactionAsync();&#10;&#10;        await DeleteExistingData(connection, new List&lt;string&gt; { &quot;MarketBookBackPrices&quot;, &quot;MarketBookLayPrices&quot; });&#10;        await ResetAutoIncrementCounters(connection, new List&lt;string&gt; { &quot;MarketBookBackPrices&quot;, &quot;MarketBookLayPrices&quot; });&#10;&#10;        try&#10;        {&#10;            foreach (var marketBook in marketBooks)&#10;            {&#10;                string marketId = marketBook.MarketId;&#10;&#10;                foreach (var runner in marketBook.Runners)&#10;                {&#10;                    if (runner.Exchange != null)&#10;                    {&#10;                        foreach (var back in runner.Exchange.AvailableToBack)&#10;                        {&#10;                            if (await IsDataExist(connection, &quot;MarketBookBackPrices&quot;, marketId, runner.SelectionId, back.Price))&#10;                            {&#10;                               //Console.WriteLine($&quot;Skipping duplicate Back bet data for Runner {runner.SelectionId}: Price = {back.Price}&quot;);&#10;                                continue;&#10;                            }&#10;&#10;                            using var priceCommand = connection.CreateCommand();&#10;                            priceCommand.CommandText = @&quot;&#10;                                INSERT INTO MarketBookBackPrices&#10;                                (MarketId, SelectionId, Price, Size, Status, LastPriceTraded, TotalMatched)&#10;                                VALUES&#10;                                ($MarketId, $SelectionId, $Price, $Size, $Status, $LastPriceTraded, $TotalMatched)&quot;;&#10;&#10;                            priceCommand.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Price&quot;, (double)back.Price);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Size&quot;, (double)back.Size);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$LastPriceTraded&quot;, runner.LastPriceTraded ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$TotalMatched&quot;, runner.TotalMatched ?? (object)DBNull.Value);&#10;&#10;                            await priceCommand.ExecuteNonQueryAsync();&#10;                        }&#10;&#10;                        foreach (var lay in runner.Exchange.AvailableToLay)&#10;                        {&#10;                            if (await IsDataExist(connection, &quot;MarketBookLayPrices&quot;, marketId, runner.SelectionId, lay.Price))&#10;                            {&#10;                               //Console.WriteLine($&quot;Skipping duplicate Lay bet data for Runner {runner.SelectionId}: Price = {lay.Price}&quot;);&#10;                                continue;&#10;                            }&#10;&#10;                            using var priceCommand = connection.CreateCommand();&#10;                            priceCommand.CommandText = @&quot;&#10;                                INSERT INTO MarketBookLayPrices&#10;                                (MarketId, SelectionId, Price, Size, Status, LastPriceTraded, TotalMatched)&#10;                                VALUES&#10;                                ($MarketId, $SelectionId, $Price, $Size, $Status, $LastPriceTraded, $TotalMatched)&quot;;&#10;&#10;                            priceCommand.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Price&quot;, (double)lay.Price);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Size&quot;, (double)lay.Size);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$LastPriceTraded&quot;, runner.LastPriceTraded ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$TotalMatched&quot;, runner.TotalMatched ?? (object)DBNull.Value);&#10;&#10;                            await priceCommand.ExecuteNonQueryAsync();&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            await transaction.CommitAsync();&#10;           //Console.WriteLine(&quot;Market book back/lay prices inserted successfully.&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            await transaction.RollbackAsync();&#10;           //Console.WriteLine($&quot;Error inserting market book prices: {ex.Message}&quot;);&#10;           //Console.WriteLine(ex.ToString());&#10;        }&#10;    }&#10;&#10;&#10;    public async Task InsertGreyhoundMarketBooksIntoDatabase(List&lt;MarketBook&lt;ApiRunner&gt;&gt; marketBooks)&#10;    {&#10;        using var connection = new SqliteConnection(_connectionString);&#10;        await connection.OpenAsync();&#10;        using var transaction = await connection.BeginTransactionAsync();&#10;&#10;        try&#10;        {&#10;            foreach (var marketBook in marketBooks)&#10;            {&#10;                string marketId = marketBook.MarketId;&#10;                var marketInfo = await GetMarketNameAndEventNameByMarketId(connection, marketId);&#10;&#10;                foreach (var runner in marketBook.Runners)&#10;                {&#10;                    if (runner.Exchange?.AvailableToBack != null)&#10;                    {&#10;                        foreach (var back in runner.Exchange.AvailableToBack)&#10;                        {&#10;                            using var command = connection.CreateCommand();&#10;                            command.CommandText = @&quot;&#10;                                INSERT INTO GreyhoundMarketBook&#10;                                (MarketId, MarketName, SelectionId, Status, PriceType, Price, Size)&#10;                                VALUES&#10;                                ($MarketId, $MarketName, $SelectionId, $Status, $PriceType, $Price, $Size)&quot;;&#10;&#10;                            command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$MarketName&quot;, marketInfo?.MarketName ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            command.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$PriceType&quot;, &quot;AvailableToBack&quot;);&#10;                            command.Parameters.AddWithValue(&quot;$Price&quot;, (double)back.Price);&#10;                            command.Parameters.AddWithValue(&quot;$Size&quot;, (double)back.Size);&#10;&#10;                            await command.ExecuteNonQueryAsync();&#10;                        }&#10;                    }&#10;&#10;                    if (runner.Exchange?.AvailableToLay != null)&#10;                    {&#10;                        foreach (var lay in runner.Exchange.AvailableToLay)&#10;                        {&#10;                            using var command = connection.CreateCommand();&#10;                            command.CommandText = @&quot;&#10;                                INSERT INTO GreyhoundMarketBook&#10;                                (MarketId, MarketName, SelectionId, Status, PriceType, Price, Size)&#10;                                VALUES&#10;                                ($MarketId, $MarketName, $SelectionId, $Status, $PriceType, $Price, $Size)&quot;;&#10;&#10;                            command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$MarketName&quot;, marketInfo?.MarketName ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            command.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$PriceType&quot;, &quot;AvailableToLay&quot;);&#10;                            command.Parameters.AddWithValue(&quot;$Price&quot;, (double)lay.Price);&#10;                            command.Parameters.AddWithValue(&quot;$Size&quot;, (double)lay.Size);&#10;&#10;                            await command.ExecuteNonQueryAsync();&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            await transaction.CommitAsync();&#10;            //Console.WriteLine(&quot;Greyhound market books inserted successfully.&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            await transaction.RollbackAsync();&#10;            //Console.WriteLine($&quot;Error inserting greyhound market books: {ex.Message}&quot;);&#10;            //Console.WriteLine(ex.ToString());&#10;        }&#10;    }&#10;&#10;    public async Task&lt;List&lt;HorseMarketBook&gt;&gt; GetHorseMarketBooksAsync()&#10;{&#10;    using var connection = new SqliteConnection(_connectionString);&#10;    await connection.OpenAsync();&#10;&#10;    var query = @&quot;SELECT MarketId, MarketName, EventName, SelectionId, RUNNER_NAME as RunnerName, Status, SIRE_NAME as SireName, DAMSIRE_NAME as DamsireName, TRAINER_NAME as TrainerName, AGE, WEIGHT_VALUE as WeightValue, COLOUR_TYPE as ColourType, FORM FROM HorseMarketBook&quot;;&#10;    var result = await connection.QueryAsync&lt;HorseMarketBook&gt;(query);&#10;&#10;    return result.ToList();&#10;}&#10;&#10;    private async Task&lt;MarketInfo&gt; GetMarketNameAndEventNameByMarketId(SqliteConnection connection, string marketId)&#10;    {&#10;        using var command = connection.CreateCommand();&#10;        command.CommandText = @&quot;&#10;        SELECT MarketName, EventName&#10;        FROM EventMarkets&#10;        WHERE MarketId = $MarketId&#10;        LIMIT 1&quot;;&#10;        command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId);&#10;&#10;        using var reader = await command.ExecuteReaderAsync();&#10;        if (await reader.ReadAsync())&#10;        {&#10;            return new MarketInfo&#10;            {&#10;                MarketName = reader.GetString(0),&#10;                EventName = reader.GetString(1)&#10;            };&#10;        }&#10;&#10;        Console.WriteLine($&quot;No matching MarketId found in EventMarkets for MarketId: {marketId}&quot;);&#10;        return new MarketInfo { MarketName = &quot;Unknown&quot;, EventName = &quot;Unknown&quot; };&#10;    }&#10;&#10;    private static int? ParseNullableInt(string input) =&gt;&#10;        int.TryParse(input, out var result) ? result : null;&#10;&#10;    private static double? ParseNullableDouble(string input) =&gt;&#10;        double.TryParse(input, out var result) ? result : null;&#10;&#10;    private async Task DeleteExistingData(SqliteConnection connection, List&lt;string&gt; tableNames)&#10;    {&#10;        // Method removed as per request to avoid deletion logic.&#10;    }&#10;&#10;    private async Task&lt;bool&gt; IsDataExist(SqliteConnection connection, string tableName, object marketId, object selectionId, object price)&#10;    {&#10;        using var command = connection.CreateCommand();&#10;        command.CommandText = $@&quot;&#10;        SELECT COUNT(1)&#10;        FROM {tableName}&#10;        WHERE MarketId = $MarketId&#10;        AND SelectionId = $SelectionId&#10;        AND Price = $Price&quot;;&#10;&#10;        command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId);&#10;        command.Parameters.AddWithValue(&quot;$SelectionId&quot;, selectionId);&#10;        command.Parameters.AddWithValue(&quot;$Price&quot;, price ?? (object)DBNull.Value);&#10;&#10;        var count = await command.ExecuteScalarAsync();&#10;        return (long)count &gt; 0;&#10;    }&#10;&#10;    private async Task ResetAutoIncrementCounters(SqliteConnection connection, List&lt;string&gt; tableNames)&#10;    {&#10;        foreach (var table in tableNames)&#10;        {&#10;            using var resetCommand = connection.CreateCommand();&#10;            resetCommand.CommandText = $&quot;DELETE FROM SQLITE_SEQUENCE WHERE NAME = '{table}'&quot;;&#10;            await resetCommand.ExecuteNonQueryAsync();&#10;        }&#10;    }&#10;&#10;    public async Task DeleteFinishedRacesAsync()&#10;    {&#10;        // Method removed as per request to avoid deletion logic.&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Betfair/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Betfair/Program.cs" />
              <option name="originalContent" value="using Betfair.Data;&#10;using Betfair.Services;&#10;using Betfair.AutomationServices;&#10;using Betfair.Handlers;&#10;using Betfair.Services.Account;&#10;using Betfair.Services.HistoricalData;&#10;using Betfair.Settings;&#10;using Microsoft.AspNetCore.Connections;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;builder.Logging.AddConsole();&#10;&#10;// Add configuration to access appsettings.json or other sources&#10;builder.Configuration.AddJsonFile(&quot;appsettings.json&quot;, optional: false, reloadOnChange: true);&#10;&#10;// Retrieve the connection string from configuration&#10;var connectionString = builder.Configuration.GetConnectionString(&quot;DefaultDb&quot;);&#10;&#10;builder.Services.Configure&lt;EndpointSettings&gt;(builder.Configuration.GetSection(&quot;EndpointUrls&quot;));&#10;builder.Services.Configure&lt;AuthSettings&gt;(builder.Configuration.GetSection(&quot;Auth&quot;));&#10;&#10;// Register the auth service&#10;builder.Services.AddSingleton&lt;BetfairAuthService&gt;();&#10;&#10;// Register http client services&#10;builder.Services.AddHttpClient&lt;ICompetitionService, CompetitionService&gt;((sp, client) =&gt;&#10;{&#10;    BetfairHttpClientFactory.ConfigureBetfairClient(client, sp);&#10;}).ConfigurePrimaryHttpMessageHandler(sp =&gt;&#10;{&#10;    return BetfairHttpClientFactory.CreateBetfairHandler(sp);&#10;});&#10;&#10;builder.Services.AddHttpClient&lt;IEventService, EventService&gt;((sp, client) =&gt;&#10;{&#10;    BetfairHttpClientFactory.ConfigureBetfairClient(client, sp);&#10;}).ConfigurePrimaryHttpMessageHandler(sp =&gt;&#10;{&#10;    return BetfairHttpClientFactory.CreateBetfairHandler(sp);&#10;});&#10;&#10;&#10;builder.Services.AddHttpClient&lt;IMarketApiService, MarketApiService&gt;((sp, client) =&gt;&#10;{&#10;    BetfairHttpClientFactory.ConfigureBetfairClient(client, sp);&#10;}).ConfigurePrimaryHttpMessageHandler(sp =&gt;&#10;{&#10;    return BetfairHttpClientFactory.CreateBetfairHandler(sp);&#10;});&#10;&#10;builder.Services.AddHttpClient&lt;IPlaceOrderService, PlaceOrderService&gt;((sp, client) =&gt;&#10;{&#10;    BetfairHttpClientFactory.ConfigureBetfairClient(client, sp);&#10;}).ConfigurePrimaryHttpMessageHandler(sp =&gt;&#10;{&#10;    return BetfairHttpClientFactory.CreateBetfairHandler(sp);&#10;});&#10;&#10;builder.Services.AddHttpClient&lt;AccountService&gt;((sp, client) =&gt;&#10;{&#10;    BetfairHttpClientFactory.ConfigureBetfairClient(client, sp);&#10;}).ConfigurePrimaryHttpMessageHandler(sp =&gt;&#10;{&#10;    return BetfairHttpClientFactory.CreateBetfairHandler(sp);&#10;});&#10;&#10;builder.Services.AddHttpClient&lt;HistoricalDataService&gt;((sp, client) =&gt;&#10;{&#10;    BetfairHttpClientFactory.ConfigureBetfairClient(client, sp);&#10;}).ConfigurePrimaryHttpMessageHandler(sp =&gt;&#10;{&#10;    return BetfairHttpClientFactory.CreateBetfairHandler(sp);&#10;});&#10;&#10;// Register database services with the connection string&#10;builder.Services.AddSingleton(new CompetitionDb(connectionString));&#10;builder.Services.AddSingleton(new ListMarketCatalogueDb(connectionString));&#10;builder.Services.AddSingleton(new MarketBookDb(connectionString));&#10;builder.Services.AddSingleton(new EventDb2(connectionString));&#10;builder.Services.AddSingleton(new MarketProfitAndLossDb(connectionString));&#10;builder.Services.AddSingleton(new HistoricalDataDb(connectionString));&#10;&#10;// Register scoped services&#10;builder.Services.AddScoped&lt;CompetitionAutomationService&gt;();&#10;builder.Services.AddScoped&lt;MarketAutomationService&gt;();&#10;builder.Services.AddScoped&lt;EventAutomationService&gt;();&#10;builder.Services.AddScoped&lt;GreyhoundAutomationService&gt;();&#10;builder.Services.AddScoped&lt;HorseRacingAutomationService&gt;();&#10;&#10;// Register hosted services&#10;//builder.Services.AddHostedService&lt;BetfairAutomationService&gt;();&#10;builder.Services.AddHostedService&lt;HorseRacingStartupService&gt;();&#10;&#10;builder.Services.AddScoped&lt;DatabaseService&gt;(provider =&gt; new DatabaseService(connectionString));&#10;&#10;// Add controllers&#10;builder.Services.AddControllers();&#10;&#10;// Add Swagger&#10;builder.Services.AddSwaggerGen();&#10;&#10;builder.Services.AddCors(options =&gt;&#10;{&#10;    options.AddDefaultPolicy(policy =&gt;&#10;    {&#10;        policy.AllowAnyOrigin()&#10;              .AllowAnyHeader()&#10;              .AllowAnyMethod();&#10;    });&#10;});&#10;&#10;// Initialize SQLite and set provider&#10;SQLitePCL.Batteries_V2.Init();&#10;SQLitePCL.raw.SetProvider(new SQLitePCL.SQLite3Provider_e_sqlite3());&#10;&#10;var app = builder.Build();&#10;&#10;// Use a random available port if the default port is in use&#10;var port = Environment.GetEnvironmentVariable(&quot;PORT&quot;) ?? &quot;5000&quot;;&#10;try&#10;{&#10;    app.Urls.Add($&quot;http://0.0.0.0:{port}&quot;);&#10;catch (IOException ex) when (ex.InnerException is AddressInUseException)&#10;{&#10;    Console.WriteLine($&quot;Port {port} is in use. Selecting a random available port.&quot;);&#10;    Console.WriteLine($&quot;Port {port} is in use. Selecting a random available port.&quot;);&#10;    app.Urls.Add(&quot;http://0.0.0.0:0&quot;); // Bind to a random port&#10;&#10;// Configure Swagger&#10;app.UseSwagger();&#10;app.UseSwaggerUI(c =&gt;&#10;{&#10;    c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;API Documentation V1&quot;);&#10;});&#10;&#10;// Configure the HTTP request pipeline&#10;app.UseHttpsRedirection();&#10;app.UseRouting();&#10;app.UseAuthorization();&#10;app.MapControllers();&#10;app.UseCors();&#10;app.Run();&#10;" />
              <option name="updatedContent" value="using Betfair.Data;&#10;using Betfair.Services;&#10;using Betfair.AutomationServices;&#10;using Betfair.Handlers;&#10;using Betfair.Services.Account;&#10;using Betfair.Services.HistoricalData;&#10;using Betfair.Settings;&#10;using Microsoft.AspNetCore.Connections;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;builder.Logging.AddConsole();&#10;&#10;// Add configuration to access appsettings.json or other sources&#10;builder.Configuration.AddJsonFile(&quot;appsettings.json&quot;, optional: false, reloadOnChange: true);&#10;&#10;// Retrieve the connection string from configuration&#10;var connectionString = builder.Configuration.GetConnectionString(&quot;DefaultDb&quot;);&#10;&#10;builder.Services.Configure&lt;EndpointSettings&gt;(builder.Configuration.GetSection(&quot;EndpointUrls&quot;));&#10;builder.Services.Configure&lt;AuthSettings&gt;(builder.Configuration.GetSection(&quot;Auth&quot;));&#10;&#10;// Register the auth service&#10;builder.Services.AddSingleton&lt;BetfairAuthService&gt;();&#10;&#10;// Register http client services&#10;builder.Services.AddHttpClient&lt;ICompetitionService, CompetitionService&gt;((sp, client) =&gt;&#10;{&#10;    BetfairHttpClientFactory.ConfigureBetfairClient(client, sp);&#10;}).ConfigurePrimaryHttpMessageHandler(sp =&gt;&#10;{&#10;    return BetfairHttpClientFactory.CreateBetfairHandler(sp);&#10;});&#10;&#10;builder.Services.AddHttpClient&lt;IEventService, EventService&gt;((sp, client) =&gt;&#10;{&#10;    BetfairHttpClientFactory.ConfigureBetfairClient(client, sp);&#10;}).ConfigurePrimaryHttpMessageHandler(sp =&gt;&#10;{&#10;    return BetfairHttpClientFactory.CreateBetfairHandler(sp);&#10;});&#10;&#10;&#10;builder.Services.AddHttpClient&lt;IMarketApiService, MarketApiService&gt;((sp, client) =&gt;&#10;{&#10;    BetfairHttpClientFactory.ConfigureBetfairClient(client, sp);&#10;}).ConfigurePrimaryHttpMessageHandler(sp =&gt;&#10;{&#10;    return BetfairHttpClientFactory.CreateBetfairHandler(sp);&#10;});&#10;&#10;builder.Services.AddHttpClient&lt;IPlaceOrderService, PlaceOrderService&gt;((sp, client) =&gt;&#10;{&#10;    BetfairHttpClientFactory.ConfigureBetfairClient(client, sp);&#10;}).ConfigurePrimaryHttpMessageHandler(sp =&gt;&#10;{&#10;    return BetfairHttpClientFactory.CreateBetfairHandler(sp);&#10;});&#10;&#10;builder.Services.AddHttpClient&lt;AccountService&gt;((sp, client) =&gt;&#10;{&#10;    BetfairHttpClientFactory.ConfigureBetfairClient(client, sp);&#10;}).ConfigurePrimaryHttpMessageHandler(sp =&gt;&#10;{&#10;    return BetfairHttpClientFactory.CreateBetfairHandler(sp);&#10;});&#10;&#10;builder.Services.AddHttpClient&lt;HistoricalDataService&gt;((sp, client) =&gt;&#10;{&#10;    BetfairHttpClientFactory.ConfigureBetfairClient(client, sp);&#10;}).ConfigurePrimaryHttpMessageHandler(sp =&gt;&#10;{&#10;    return BetfairHttpClientFactory.CreateBetfairHandler(sp);&#10;});&#10;&#10;// Register database services with the connection string&#10;builder.Services.AddSingleton(new CompetitionDb(connectionString));&#10;builder.Services.AddSingleton(new ListMarketCatalogueDb(connectionString));&#10;builder.Services.AddSingleton(new MarketBookDb(connectionString));&#10;builder.Services.AddSingleton(new EventDb2(connectionString));&#10;builder.Services.AddSingleton(new MarketProfitAndLossDb(connectionString));&#10;builder.Services.AddSingleton(new HistoricalDataDb(connectionString));&#10;&#10;// Register scoped services&#10;builder.Services.AddScoped&lt;CompetitionAutomationService&gt;();&#10;builder.Services.AddScoped&lt;MarketAutomationService&gt;();&#10;builder.Services.AddScoped&lt;EventAutomationService&gt;();&#10;builder.Services.AddScoped&lt;GreyhoundAutomationService&gt;();&#10;builder.Services.AddScoped&lt;HorseRacingAutomationService&gt;();&#10;&#10;// Register hosted services&#10;//builder.Services.AddHostedService&lt;BetfairAutomationService&gt;();&#10;builder.Services.AddHostedService&lt;HorseRacingStartupService&gt;();&#10;&#10;builder.Services.AddScoped&lt;DatabaseService&gt;(provider =&gt; new DatabaseService(connectionString));&#10;&#10;// Add controllers&#10;builder.Services.AddControllers();&#10;&#10;// Add Swagger&#10;builder.Services.AddSwaggerGen();&#10;&#10;builder.Services.AddCors(options =&gt;&#10;{&#10;    options.AddDefaultPolicy(policy =&gt;&#10;    {&#10;        policy.AllowAnyOrigin()&#10;              .AllowAnyHeader()&#10;              .AllowAnyMethod();&#10;    });&#10;});&#10;&#10;// Initialize SQLite and set provider&#10;SQLitePCL.Batteries_V2.Init();&#10;SQLitePCL.raw.SetProvider(new SQLitePCL.SQLite3Provider_e_sqlite3());&#10;&#10;var app = builder.Build();&#10;&#10;// Ensure the application uses the specified port or logs an error if unavailable&#10;var port = Environment.GetEnvironmentVariable(&quot;PORT&quot;) ?? &quot;5173&quot;;&#10;try&#10;{&#10;    app.Urls.Add($&quot;http://0.0.0.0:{port}&quot;);&#10;    Console.WriteLine($&quot;Application starting on port {port}.&quot;);&#10;}&#10;catch (IOException ex) when (ex.InnerException is AddressInUseException)&#10;{&#10;    Console.WriteLine($&quot;Error: Port {port} is already in use. Please stop the conflicting process or specify a different port using the PORT environment variable.&quot;);&#10;    Environment.Exit(1); // Exit the application&#10;}&#10;&#10;// Configure Swagger&#10;app.UseSwagger();&#10;app.UseSwaggerUI(c =&gt;&#10;{&#10;    c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;API Documentation V1&quot;);&#10;});&#10;&#10;// Configure the HTTP request pipeline&#10;app.UseHttpsRedirection();&#10;app.UseRouting();&#10;app.UseAuthorization();&#10;app.MapControllers();&#10;app.UseCors();&#10;app.Run();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Betfair/Services/MarketApiService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Betfair/Services/MarketApiService.cs" />
              <option name="originalContent" value="using System.Net.Http.Headers;&#10;using System.Text;&#10;using System.Text.Json;&#10;using Betfair.Data;&#10;using Betfair.Models.Market;&#10;using Betfair.Services.Account;&#10;using Betfair.Settings;&#10;using Microsoft.Extensions.Options;&#10;&#10;namespace Betfair.Services;&#10;public class MarketApiService : IMarketApiService&#10;{&#10;    private readonly HttpClient _httpClient;&#10;    private readonly BetfairAuthService _authService;&#10;    private readonly MarketProfitAndLossDb _marketProfitAndLossDb;&#10;    private readonly EndpointSettings _settings; &#10;    private string _sessionToken;&#10;&#10;    public MarketApiService(HttpClient httpClient, BetfairAuthService authService, IOptions&lt;EndpointSettings&gt; options, MarketProfitAndLossDb marketProfitAndLossDb)&#10;    {&#10;        _httpClient = httpClient;&#10;        _authService = authService; &#10;        _settings = options.Value;&#10;        _marketProfitAndLossDb = marketProfitAndLossDb;&#10;    }&#10;&#10;    public async Task&lt;string&gt; ListMarketCatalogue(string competitionId = null, string eventId = null)&#10;    {&#10;        _sessionToken = await _authService.GetSessionTokenAsync(); &#10;        &#10;        var filter = new&#10;        {&#10;            competitionIds = competitionId != null ? new[] { competitionId } : null,&#10;            eventIds = eventId != null ? new[] { eventId } : null&#10;        };&#10;&#10;        var requestBody = new&#10;        {&#10;            jsonrpc = &quot;2.0&quot;,&#10;            method = &quot;SportsAPING/v1.0/listMarketCatalogue&quot;,&#10;            @params = new&#10;            {&#10;                filter = filter,&#10;                maxResults = 1000,&#10;                marketProjection = new[] { &quot;COMPETITION&quot;, &quot;EVENT&quot;, &quot;EVENT_TYPE&quot;, &quot;RUNNER_DESCRIPTION&quot;, &quot;RUNNER_METADATA&quot; }&#10;&#10;            },&#10;            id = 1&#10;        };&#10;&#10;        _httpClient.DefaultRequestHeaders.Remove(&quot;X-Authentication&quot;);&#10;        _httpClient.DefaultRequestHeaders.Add(&quot;X-Authentication&quot;, _sessionToken);&#10;&#10;        var content = new StringContent(JsonSerializer.Serialize(requestBody), Encoding.UTF8, &quot;application/json&quot;);&#10;        var response = await _httpClient.PostAsync(_settings.ExchangeEndpoint, content);&#10;        response.EnsureSuccessStatusCode();&#10;&#10;        var jsonResponse = await response.Content.ReadAsStringAsync();&#10;        // Print raw JSON response to//Console or log&#10;        //Console.WriteLine(&quot;Raw Market Catalogue JSON Response:&quot;);&#10;        //Console.WriteLine(jsonResponse);&#10;&#10;        return await response.Content.ReadAsStringAsync(); &#10;    }&#10;&#10;    public async Task&lt;string&gt; ListMarketBookAsync(List&lt;string&gt; marketIds)&#10;    {&#10;        _sessionToken = await _authService.GetSessionTokenAsync();&#10;        const int maxMarketIds = 10;&#10;&#10;        var limitedMarketIds = marketIds.Take(maxMarketIds).ToList();&#10;&#10;        var requestBody = new&#10;        {&#10;            jsonrpc = &quot;2.0&quot;,&#10;            method = &quot;SportsAPING/v1.0/listMarketBook&quot;,&#10;            @params = new&#10;            {&#10;                marketIds = limitedMarketIds,&#10;                priceProjection = new { priceData = new[] { &quot;EX_BEST_OFFERS&quot;, &quot;EX_TRADED&quot; } }&#10;            },&#10;            id = 1&#10;        };&#10;&#10;        _httpClient.DefaultRequestHeaders.Remove(&quot;X-Authentication&quot;);&#10;        _httpClient.DefaultRequestHeaders.Add(&quot;X-Authentication&quot;, _sessionToken);&#10;&#10;        var content = new StringContent(JsonSerializer.Serialize(requestBody), Encoding.UTF8, &quot;application/json&quot;);&#10;        var response = await _httpClient.PostAsync(_settings.ExchangeEndpoint, content);&#10;        response.EnsureSuccessStatusCode();&#10;        return await response.Content.ReadAsStringAsync();&#10;    }&#10;    public async Task&lt;string&gt; ListHorseRacingMarketCatalogueAsync(string eventTypeId = null, string eventId = null, DateTime? openDate = null)&#10;    {&#10;        try&#10;        {&#10;            _sessionToken = await _authService.GetSessionTokenAsync();&#10;&#10;            // Only include open and upcoming races (OPEN markets)&#10;            };&#10;                marketStatuses = new[] { &quot;OPEN&quot; }&#10;            {&#10;                marketStatuses = new[] { &quot;OPEN&quot; }&#10;                @params = new&#10;                marketStatuses = new[] { &quot;OPEN&quot; }&#10;                    maxResults = 100,&#10;                    marketProjection = new[] { &quot;COMPETITION&quot;, &quot;EVENT&quot;, &quot;EVENT_TYPE&quot;, &quot;RUNNER_DESCRIPTION&quot;, &quot;RUNNER_METADATA&quot; }&#10;                },&#10;                id = 1&#10;            };&#10;&#10;            _httpClient.DefaultRequestHeaders.Remove(&quot;X-Authentication&quot;);&#10;            _httpClient.DefaultRequestHeaders.Add(&quot;X-Authentication&quot;, _sessionToken);&#10;&#10;            var content = new StringContent(JsonSerializer.Serialize(requestBody), Encoding.UTF8, &quot;application/json&quot;);&#10;            var response = await _httpClient.PostAsync(_settings.ExchangeEndpoint, content);&#10;            response.EnsureSuccessStatusCode();&#10;&#10;            var jsonResponse = await response.Content.ReadAsStringAsync();&#10;&#10;            // Debugging: Log the raw response to check if the response format is as expected&#10;           //Console.WriteLine(&quot;--- Raw Market Catalogue JSON ---&quot;);&#10;           //Console.WriteLine(jsonResponse);&#10;&#10;            return jsonResponse;&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            // Log the error&#10;           //Console.WriteLine($&quot;Error in ListHorseRacingMarketCatalogueAsync: {ex.Message}&quot;);&#10;            return string.Empty; // Return empty string or handle accordingly&#10;        }&#10;    }&#10;&#10;     public async Task&lt;string&gt; GetMarketProfitAndLossAsync(List&lt;string&gt; marketIds)&#10;        {&#10;            _sessionToken = await _authService.GetSessionTokenAsync();&#10;            &#10;            var requestBody = new&#10;            {&#10;                jsonrpc = &quot;2.0&quot;,&#10;                method = &quot;SportsAPING/v1.0/listMarketProfitAndLoss&quot;,&#10;                @params = new&#10;                {&#10;                    marketIds&#10;                },&#10;                id = 1&#10;            };&#10;&#10;            _httpClient.DefaultRequestHeaders.Remove(&quot;X-Authentication&quot;);&#10;            _httpClient.DefaultRequestHeaders.Add(&quot;X-Authentication&quot;, _sessionToken);&#10;&#10;            var content = new StringContent(JsonSerializer.Serialize(requestBody), Encoding.UTF8, &quot;application/json&quot;);&#10;            var response = await _httpClient.PostAsync(_settings.ExchangeEndpoint, content);&#10;            response.EnsureSuccessStatusCode();&#10;            return await response.Content.ReadAsStringAsync(); &#10;        }&#10;      &#10;    public async Task ProcessAndStoreMarketProfitAndLoss(List&lt;string&gt; marketIds)&#10;    {&#10;        try&#10;        {&#10;            var responseJson = await GetMarketProfitAndLossAsync(marketIds);&#10;&#10;            var result = JsonSerializer.Deserialize&lt;MarketProfitAndLossApiResponse&gt;(responseJson);&#10;&#10;            if (result?.Result?.Count &gt; 0)&#10;            {&#10;                List&lt;MarketProfitAndLoss&gt; marketProfitAndLossList = new List&lt;MarketProfitAndLoss&gt;();&#10;&#10;                foreach (var market in result.Result)&#10;                {&#10;                    var marketProfitAndLoss = new MarketProfitAndLoss&#10;                    {&#10;                        MarketId = market.MarketId,&#10;                        ProfitAndLosses = new List&lt;BetProfitAndLoss&gt;()&#10;                    };&#10;&#10;                    foreach (var profitLoss in market.ProfitAndLosses)&#10;                    {&#10;                        var betProfitAndLoss = new BetProfitAndLoss&#10;                        {&#10;                            SelectionId = profitLoss.SelectionId,&#10;                            IfWin = profitLoss.IfWin&#10;                        };&#10;&#10;                        marketProfitAndLoss.ProfitAndLosses.Add(betProfitAndLoss);&#10;                    }&#10;                    &#10;                    marketProfitAndLossList.Add(marketProfitAndLoss);&#10;                }&#10;&#10;                await _marketProfitAndLossDb.InsertMarketProfitAndLossIntoDatabase(marketProfitAndLossList);&#10;            }&#10;            else&#10;            {&#10;                //Console.WriteLine(&quot;No market profit and loss data found.&quot;);&#10;            }&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            //Console.WriteLine($&quot;Failed to fetch and store Market Profit and Loss data: {ex.Message}&quot;);&#10;        }&#10;    }&#10;}&#10;&#10;&#10;public interface IMarketApiService&#10;{&#10;    Task&lt;string&gt; ListMarketCatalogue(string competitionId = null, string eventId = null);&#10;    Task&lt;string&gt; ListMarketBookAsync(List&lt;string&gt; marketIds);&#10;    Task&lt;string&gt; GetMarketProfitAndLossAsync(List&lt;string&gt; marketIds);&#10;    Task ProcessAndStoreMarketProfitAndLoss(List&lt;string&gt; marketIds);&#10;&#10;    Task&lt;string&gt; ListHorseRacingMarketCatalogueAsync(string eventTypeId = null, string eventId = null,&#10;        DateTime? openDate = null);&#10;}&#10;" />
              <option name="updatedContent" value="using System.Net.Http.Headers;&#10;using System.Text;&#10;using System.Text.Json;&#10;using Betfair.Data;&#10;using Betfair.Models.Market;&#10;using Betfair.Services.Account;&#10;using Betfair.Settings;&#10;using Microsoft.Extensions.Options;&#10;&#10;namespace Betfair.Services;&#10;public class MarketApiService : IMarketApiService&#10;{&#10;    private readonly HttpClient _httpClient;&#10;    private readonly BetfairAuthService _authService;&#10;    private readonly MarketProfitAndLossDb _marketProfitAndLossDb;&#10;    private readonly EndpointSettings _settings; &#10;    private string _sessionToken;&#10;&#10;    public MarketApiService(HttpClient httpClient, BetfairAuthService authService, IOptions&lt;EndpointSettings&gt; options, MarketProfitAndLossDb marketProfitAndLossDb)&#10;    {&#10;        _httpClient = httpClient;&#10;        _authService = authService; &#10;        _settings = options.Value;&#10;        _marketProfitAndLossDb = marketProfitAndLossDb;&#10;    }&#10;&#10;    public async Task&lt;string&gt; ListMarketCatalogue(string competitionId = null, string eventId = null)&#10;    {&#10;        _sessionToken = await _authService.GetSessionTokenAsync(); &#10;        &#10;        var filter = new&#10;        {&#10;            competitionIds = competitionId != null ? new[] { competitionId } : null,&#10;            eventIds = eventId != null ? new[] { eventId } : null&#10;        };&#10;&#10;        var requestBody = new&#10;        {&#10;            jsonrpc = &quot;2.0&quot;,&#10;            method = &quot;SportsAPING/v1.0/listMarketCatalogue&quot;,&#10;            @params = new&#10;            {&#10;                filter = filter,&#10;                maxResults = 1000,&#10;                marketProjection = new[] { &quot;COMPETITION&quot;, &quot;EVENT&quot;, &quot;EVENT_TYPE&quot;, &quot;RUNNER_DESCRIPTION&quot;, &quot;RUNNER_METADATA&quot; }&#10;&#10;            },&#10;            id = 1&#10;        };&#10;&#10;        _httpClient.DefaultRequestHeaders.Remove(&quot;X-Authentication&quot;);&#10;        _httpClient.DefaultRequestHeaders.Add(&quot;X-Authentication&quot;, _sessionToken);&#10;&#10;        var content = new StringContent(JsonSerializer.Serialize(requestBody), Encoding.UTF8, &quot;application/json&quot;);&#10;        var response = await _httpClient.PostAsync(_settings.ExchangeEndpoint, content);&#10;        response.EnsureSuccessStatusCode();&#10;&#10;        var jsonResponse = await response.Content.ReadAsStringAsync();&#10;        // Print raw JSON response to//Console or log&#10;        //Console.WriteLine(&quot;Raw Market Catalogue JSON Response:&quot;);&#10;        //Console.WriteLine(jsonResponse);&#10;&#10;        return await response.Content.ReadAsStringAsync(); &#10;    }&#10;&#10;    public async Task&lt;string&gt; ListMarketBookAsync(List&lt;string&gt; marketIds)&#10;    {&#10;        _sessionToken = await _authService.GetSessionTokenAsync();&#10;        const int maxMarketIds = 10;&#10;&#10;        var limitedMarketIds = marketIds.Take(maxMarketIds).ToList();&#10;&#10;        var requestBody = new&#10;        {&#10;            jsonrpc = &quot;2.0&quot;,&#10;            method = &quot;SportsAPING/v1.0/listMarketBook&quot;,&#10;            @params = new&#10;            {&#10;                marketIds = limitedMarketIds,&#10;                priceProjection = new { priceData = new[] { &quot;EX_BEST_OFFERS&quot;, &quot;EX_TRADED&quot; } }&#10;            },&#10;            id = 1&#10;        };&#10;&#10;        _httpClient.DefaultRequestHeaders.Remove(&quot;X-Authentication&quot;);&#10;        _httpClient.DefaultRequestHeaders.Add(&quot;X-Authentication&quot;, _sessionToken);&#10;&#10;        var content = new StringContent(JsonSerializer.Serialize(requestBody), Encoding.UTF8, &quot;application/json&quot;);&#10;        var response = await _httpClient.PostAsync(_settings.ExchangeEndpoint, content);&#10;        response.EnsureSuccessStatusCode();&#10;        return await response.Content.ReadAsStringAsync();&#10;    }&#10;    public async Task&lt;string&gt; ListHorseRacingMarketCatalogueAsync(string eventTypeId = null, string eventId = null, DateTime? openDate = null)&#10;    {&#10;        try&#10;        {&#10;            _sessionToken = await _authService.GetSessionTokenAsync();&#10;&#10;            // Only include open and upcoming races (OPEN markets) for today&#10;            var todayUtc = DateTime.UtcNow.Date;&#10;            var tomorrowUtc = todayUtc.AddDays(1);&#10;            var filter = new&#10;            {&#10;                eventTypeIds = eventTypeId != null ? new[] { eventTypeId } : null,&#10;                eventIds = eventId != null ? new[] { eventId } : null,&#10;                marketTypeCodes = new[] { &quot;WIN&quot;, &quot;PLACE&quot; },&#10;                marketStatuses = new[] { &quot;OPEN&quot; },&#10;                marketStartTime = new { from = todayUtc, to = tomorrowUtc }&#10;            };&#10;&#10;            var requestBody = new&#10;            {&#10;                jsonrpc = &quot;2.0&quot;,&#10;                method = &quot;SportsAPING/v1.0/listMarketCatalogue&quot;,&#10;                @params = new&#10;                {&#10;                    filter = filter,&#10;                    maxResults = 100,&#10;                    marketProjection = new[] { &quot;COMPETITION&quot;, &quot;EVENT&quot;, &quot;EVENT_TYPE&quot;, &quot;RUNNER_DESCRIPTION&quot;, &quot;RUNNER_METADATA&quot; }&#10;                },&#10;                id = 1&#10;            };&#10;&#10;            _httpClient.DefaultRequestHeaders.Remove(&quot;X-Authentication&quot;);&#10;            _httpClient.DefaultRequestHeaders.Add(&quot;X-Authentication&quot;, _sessionToken);&#10;&#10;            var content = new StringContent(JsonSerializer.Serialize(requestBody), Encoding.UTF8, &quot;application/json&quot;);&#10;            var response = await _httpClient.PostAsync(_settings.ExchangeEndpoint, content);&#10;            response.EnsureSuccessStatusCode();&#10;&#10;            var jsonResponse = await response.Content.ReadAsStringAsync();&#10;&#10;            // Debugging: Log the raw response to check if the response format is as expected&#10;           //Console.WriteLine(&quot;--- Raw Market Catalogue JSON ---&quot;);&#10;           //Console.WriteLine(jsonResponse);&#10;&#10;            return jsonResponse;&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            // Log the error&#10;           //Console.WriteLine($&quot;Error in ListHorseRacingMarketCatalogueAsync: {ex.Message}&quot;);&#10;            return string.Empty; // Return empty string or handle accordingly&#10;        }&#10;    }&#10;&#10;     public async Task&lt;string&gt; GetMarketProfitAndLossAsync(List&lt;string&gt; marketIds)&#10;        {&#10;            _sessionToken = await _authService.GetSessionTokenAsync();&#10;            &#10;            var requestBody = new&#10;            {&#10;                jsonrpc = &quot;2.0&quot;,&#10;                method = &quot;SportsAPING/v1.0/listMarketProfitAndLoss&quot;,&#10;                @params = new&#10;                {&#10;                    marketIds&#10;                },&#10;                id = 1&#10;            };&#10;&#10;            _httpClient.DefaultRequestHeaders.Remove(&quot;X-Authentication&quot;);&#10;            _httpClient.DefaultRequestHeaders.Add(&quot;X-Authentication&quot;, _sessionToken);&#10;&#10;            var content = new StringContent(JsonSerializer.Serialize(requestBody), Encoding.UTF8, &quot;application/json&quot;);&#10;            var response = await _httpClient.PostAsync(_settings.ExchangeEndpoint, content);&#10;            response.EnsureSuccessStatusCode();&#10;            return await response.Content.ReadAsStringAsync(); &#10;        }&#10;      &#10;    public async Task ProcessAndStoreMarketProfitAndLoss(List&lt;string&gt; marketIds)&#10;    {&#10;        try&#10;        {&#10;            var responseJson = await GetMarketProfitAndLossAsync(marketIds);&#10;&#10;            var result = JsonSerializer.Deserialize&lt;MarketProfitAndLossApiResponse&gt;(responseJson);&#10;&#10;            if (result?.Result?.Count &gt; 0)&#10;            {&#10;                List&lt;MarketProfitAndLoss&gt; marketProfitAndLossList = new List&lt;MarketProfitAndLoss&gt;();&#10;&#10;                foreach (var market in result.Result)&#10;                {&#10;                    var marketProfitAndLoss = new MarketProfitAndLoss&#10;                    {&#10;                        MarketId = market.MarketId,&#10;                        ProfitAndLosses = new List&lt;BetProfitAndLoss&gt;()&#10;                    };&#10;&#10;                    foreach (var profitLoss in market.ProfitAndLosses)&#10;                    {&#10;                        var betProfitAndLoss = new BetProfitAndLoss&#10;                        {&#10;                            SelectionId = profitLoss.SelectionId,&#10;                            IfWin = profitLoss.IfWin&#10;                        };&#10;&#10;                        marketProfitAndLoss.ProfitAndLosses.Add(betProfitAndLoss);&#10;                    }&#10;                    &#10;                    marketProfitAndLossList.Add(marketProfitAndLoss);&#10;                }&#10;&#10;                await _marketProfitAndLossDb.InsertMarketProfitAndLossIntoDatabase(marketProfitAndLossList);&#10;            }&#10;            else&#10;            {&#10;                //Console.WriteLine(&quot;No market profit and loss data found.&quot;);&#10;            }&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            //Console.WriteLine($&quot;Failed to fetch and store Market Profit and Loss data: {ex.Message}&quot;);&#10;        }&#10;    }&#10;}&#10;&#10;&#10;public interface IMarketApiService&#10;{&#10;    Task&lt;string&gt; ListMarketCatalogue(string competitionId = null, string eventId = null);&#10;    Task&lt;string&gt; ListMarketBookAsync(List&lt;string&gt; marketIds);&#10;    Task&lt;string&gt; GetMarketProfitAndLossAsync(List&lt;string&gt; marketIds);&#10;    Task ProcessAndStoreMarketProfitAndLoss(List&lt;string&gt; marketIds);&#10;&#10;    Task&lt;string&gt; ListHorseRacingMarketCatalogueAsync(string eventTypeId = null, string eventId = null,&#10;        DateTime? openDate = null);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>