<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Betfair/AutomatedServices/BetfairPlaceOrderBackgroundWorker.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Betfair/AutomatedServices/BetfairPlaceOrderBackgroundWorker.cs" />
              <option name="originalContent" value="using Betfair.AutomationServices;&#10;using Betfair.Handlers;&#10;using Betfair.Services.Account;&#10;using Betfair.Services;&#10;&#10;namespace Betfair.AutomatedServices;&#10;public class BetfairPlaceOrderBackgroundWorker : BackgroundService&#10;{&#10;    private readonly CompetitionAutomationService _competitionAutomationService;&#10;    private readonly MarketAutomationService _marketAutomationService;&#10;    private readonly PlaceOrderService _placeOrderService;&#10;    private readonly AccountService _accountService;&#10;    &#10;    public BetfairPlaceOrderBackgroundWorker(&#10;        CompetitionAutomationService competitionAutomationService,&#10;        MarketAutomationService marketAutomationService,&#10;        PlaceOrderService placeOrderService,&#10;        AccountService accountService) &#10;    {&#10;        _competitionAutomationService = competitionAutomationService;&#10;        _marketAutomationService = marketAutomationService;&#10;        _placeOrderService = placeOrderService;&#10;        _accountService = accountService;&#10;    }&#10;    &#10;    public class TimeRange&#10;    {&#10;        public string From { get; set; }&#10;        public string To { get; set; }&#10;    }&#10;&#10;    protected override async Task ExecuteAsync(CancellationToken stoppingToken)&#10;    {&#10;        while (!stoppingToken.IsCancellationRequested)&#10;        {&#10;            await _competitionAutomationService.ProcessCompetitionsAsync();&#10;&#10;            var currentMarketIds = await _marketAutomationService.ProcessMarketCataloguesAsync(&quot;33894244&quot;);&#10;          &#10;            await _marketAutomationService.ProcessMarketBooksAsync(new List&lt;string&gt; { &quot;1.237512511&quot; });&#10;&#10;            var accountFundsJson = await _accountService.GetAccountFundsAsync();&#10;            &#10;            DisplayHandler.DisplayAccountData(accountFundsJson); &#10;           &#10;            var accountDetails = await _accountService.GetAccountDetailsAsync();&#10;            &#10;            try&#10;            {&#10;                var locale = &quot;en_GB&quot;; &#10;                var recordCount = 100;&#10;                &#10;                var itemDateRange = new TimeRange&#10;                {&#10;                    From = &quot;2024-12-26&quot;, &#10;                    To = &quot;2024-12-27&quot;   &#10;                };&#10;&#10;                var includeItem = &quot;ALL&quot;; &#10;                var wallet = &quot;UK&quot;; &#10;          &#10;                var accountStatement = await _accountService.GetAccountStatementAsync(locale, recordCount, itemDateRange, includeItem, wallet);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                //Console.WriteLine($&quot;Error: {ex.Message}&quot;);&#10;            }&#10;            //await _databaseService.DisplayMarketBooks(currentTennisMarketIds);&#10;&#10;            await _placeOrderService.PlaceOrdersAsync(&quot;1.247146226&quot;, &quot;10109527&quot;, 1.23, 1.00, &quot;BACK&quot;);&#10;            &#10;            // var instructions = new List&lt;CancelInstruction&gt;&#10;            // {&#10;            //     new CancelInstruction { betId = &quot;372606848835&quot; } // Provide the betId to cancel a specific bet&#10;            // };&#10;            // await _orderService.CancelOrderAsync(&quot;1.237598344&quot;, instructions);&#10;&#10;            await Task.Delay(TimeSpan.FromSeconds(120), stoppingToken);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Betfair.AutomationServices;&#10;using Betfair.Handlers;&#10;using Betfair.Services.Account;&#10;using Betfair.Services;&#10;&#10;namespace Betfair.AutomatedServices;&#10;public class BetfairPlaceOrderBackgroundWorker : BackgroundService&#10;{&#10;    private readonly CompetitionAutomationService _competitionAutomationService;&#10;    private readonly MarketAutomationService _marketAutomationService;&#10;    private readonly PlaceOrderService _placeOrderService;&#10;    private readonly AccountService _accountService;&#10;    &#10;    public BetfairPlaceOrderBackgroundWorker(&#10;        CompetitionAutomationService competitionAutomationService,&#10;        MarketAutomationService marketAutomationService,&#10;        PlaceOrderService placeOrderService,&#10;        AccountService accountService) &#10;    {&#10;        _competitionAutomationService = competitionAutomationService;&#10;        _marketAutomationService = marketAutomationService;&#10;        _placeOrderService = placeOrderService;&#10;        _accountService = accountService;&#10;    }&#10;    &#10;    public class TimeRange&#10;    {&#10;        public string From { get; set; }&#10;        public string To { get; set; }&#10;    }&#10;&#10;    protected override async Task ExecuteAsync(CancellationToken stoppingToken)&#10;    {&#10;        while (!stoppingToken.IsCancellationRequested)&#10;        {&#10;            await _competitionAutomationService.ProcessCompetitionsAsync();&#10;&#10;            var currentMarketIds = await _marketAutomationService.ProcessMarketCataloguesAsync(&quot;33894244&quot;);&#10;          &#10;            await _marketAutomationService.ProcessMarketBooksAsync(new List&lt;string&gt; { &quot;1.237512511&quot; });&#10;&#10;            var accountFundsJson = await _accountService.GetAccountFundsAsync();&#10;            &#10;            DisplayHandler.DisplayAccountData(accountFundsJson); &#10;           &#10;            var accountDetails = await _accountService.GetAccountDetailsAsync();&#10;            &#10;            try&#10;            {&#10;                var locale = &quot;en_GB&quot;; &#10;                var recordCount = 100;&#10;                &#10;                var itemDateRange = new TimeRange&#10;                {&#10;                    From = &quot;2024-12-26&quot;, &#10;                    To = &quot;2024-12-27&quot;   &#10;                };&#10;&#10;                var includeItem = &quot;ALL&quot;; &#10;                var wallet = &quot;UK&quot;; &#10;          &#10;                var accountStatement = await _accountService.GetAccountStatementAsync(locale, recordCount, itemDateRange, includeItem, wallet);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                //Console.WriteLine($&quot;Error: {ex.Message}&quot;);&#10;            }&#10;            //await _databaseService.DisplayMarketBooks(currentTennisMarketIds);&#10;&#10;            // Comment out the problematic line temporarily&#10;            // await _placeOrderService.PlaceOrdersAsync(&quot;1.247146226&quot;, &quot;10109527&quot;, 1.23, 1.00, &quot;BACK&quot;);&#10;            &#10;            // var instructions = new List&lt;CancelInstruction&gt;&#10;            // {&#10;            //     new CancelInstruction { betId = &quot;372606848835&quot; } // Provide the betId to cancel a specific bet&#10;            // };&#10;            // await _orderService.CancelOrderAsync(&quot;1.237598344&quot;, instructions);&#10;&#10;            await Task.Delay(TimeSpan.FromSeconds(120), stoppingToken);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Betfair/AutomatedServices/MarketBackgroundWorker.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Betfair/AutomatedServices/MarketBackgroundWorker.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Threading;&#10;using System.Threading.Tasks;&#10;using Betfair.AutomationServices;&#10;&#10;namespace Betfair.AutomationServices&#10;{&#10;    public class MarketBackgroundWorker : BackgroundService&#10;    {&#10;        private readonly MarketAutomationService _marketAutomationService;&#10;        private readonly string _eventId;&#10;        private readonly string _competitionId;&#10;&#10;        public MarketBackgroundWorker(MarketAutomationService marketAutomationService, string eventId = null, string competitionId = null)&#10;        {&#10;            _marketAutomationService = marketAutomationService;&#10;            _eventId = eventId;&#10;            _competitionId = competitionId;&#10;        }&#10;&#10;        protected override async Task ExecuteAsync(CancellationToken stoppingToken)&#10;        {&#10;            while (!stoppingToken.IsCancellationRequested)&#10;            {&#10;                // Fetch and process market catalogues&#10;                var marketDetails = await _marketAutomationService.ProcessMarketCataloguesAsync(_eventId, _competitionId);&#10;                var marketIds = marketDetails.Select(md =&gt; md.MarketId).ToList();&#10;&#10;                // Fetch and process market books&#10;                if (marketIds.Any())&#10;                {&#10;                    await _marketAutomationService.ProcessMarketBooksAsync(marketIds);&#10;                }&#10;&#10;                await Task.Delay(TimeSpan.FromMinutes(2), stoppingToken);&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Threading;&#10;using System.Threading.Tasks;&#10;using Betfair.AutomationServices;&#10;&#10;namespace Betfair.AutomationServices&#10;{&#10;    public class MarketBackgroundWorker : BackgroundService&#10;    {&#10;        private readonly MarketAutomationService _marketAutomationService;&#10;        private readonly string _eventId;&#10;        private readonly string _competitionId;&#10;&#10;        public MarketBackgroundWorker(MarketAutomationService marketAutomationService, string eventId = null, string competitionId = null)&#10;        {&#10;            _marketAutomationService = marketAutomationService;&#10;            _eventId = eventId;&#10;            _competitionId = competitionId;&#10;        }&#10;&#10;        protected override async Task ExecuteAsync(CancellationToken stoppingToken)&#10;        {&#10;            Console.WriteLine(&quot;MarketBackgroundWorker started...&quot;);&#10;            Console.WriteLine($&quot;EventId: {_eventId}, CompetitionId: {_competitionId}&quot;);&#10;            &#10;            while (!stoppingToken.IsCancellationRequested)&#10;            {&#10;                try&#10;                {&#10;                    Console.WriteLine(&quot;Starting market processing cycle...&quot;);&#10;                    &#10;                    // Fetch and process market catalogues&#10;                    Console.WriteLine(&quot;Calling ProcessMarketCataloguesAsync...&quot;);&#10;                    var marketDetails = await _marketAutomationService.ProcessMarketCataloguesAsync(_eventId, _competitionId);&#10;                    Console.WriteLine($&quot;Retrieved {marketDetails.Count} market details&quot;);&#10;                    &#10;                    var marketIds = marketDetails.Select(md =&gt; md.MarketId).ToList();&#10;                    Console.WriteLine($&quot;Market IDs to process: {string.Join(&quot;, &quot;, marketIds)}&quot;);&#10;&#10;                    // Fetch and process market books&#10;                    if (marketIds.Any())&#10;                    {&#10;                        Console.WriteLine($&quot;Processing {marketIds.Count} market books...&quot;);&#10;                        await _marketAutomationService.ProcessMarketBooksAsync(marketIds);&#10;                        Console.WriteLine(&quot;Market books processing completed&quot;);&#10;                    }&#10;                    else&#10;                    {&#10;                        Console.WriteLine(&quot;No market IDs found, skipping market books processing&quot;);&#10;                    }&#10;&#10;                    Console.WriteLine(&quot;Waiting 2 minutes before next cycle...&quot;);&#10;                    await Task.Delay(TimeSpan.FromMinutes(2), stoppingToken);&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    Console.WriteLine($&quot;Error in MarketBackgroundWorker: {ex.Message}&quot;);&#10;                    Console.WriteLine($&quot;Stack trace: {ex.StackTrace}&quot;);&#10;                    await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken); // Wait 30 seconds before retrying&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Betfair/AutomationServices/MarketAutomationService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Betfair/AutomationServices/MarketAutomationService.cs" />
              <option name="originalContent" value="using System.Text.Json;&#10;using System.Text.RegularExpressions;&#10;using Betfair.Data;&#10;using Betfair.Mappers;&#10;using Betfair.Models;&#10;using Betfair.Models.Competition;&#10;using Betfair.Models.Event;&#10;using Betfair.Models.Market;&#10;using Betfair.Models.Runner;&#10;using Betfair.Services;&#10;&#10;namespace Betfair.AutomationServices;&#10;&#10;public class MarketDetails&#10;{&#10;    public string MarketId { get; set; }&#10;    public string MarketName { get; set; }&#10;}&#10;&#10;public class MarketAutomationService&#10;{&#10;    private readonly IMarketApiService _marketApiService;&#10;    private readonly ListMarketCatalogueDb _listMarketCatalogueDb;&#10;    private readonly MarketBookDb _marketBookDb;&#10;&#10;    public MarketAutomationService(IMarketApiService marketApiService, ListMarketCatalogueDb listMarketCatalogueDb, MarketBookDb marketBookDb)&#10;    {&#10;        _marketApiService = marketApiService;&#10;        _listMarketCatalogueDb = listMarketCatalogueDb;&#10;        _marketBookDb = marketBookDb;&#10;    }&#10;&#10;    public async Task ProcessMarketBooksAsync(List&lt;string&gt; marketIds)&#10;    {&#10;        Console.WriteLine(&quot;Starting ProcessMarketBooksAsync...&quot;);&#10;        Console.WriteLine($&quot;Market IDs: {string.Join(&quot;, &quot;, marketIds)}&quot;);&#10;&#10;        var marketBookJson = await _marketApiService.ListMarketBookAsync(marketIds);&#10;        var marketBookApiResponse = JsonSerializer.Deserialize&lt;ApiResponse&lt;MarketBook&lt;ApiRunner&gt;&gt;&gt;(marketBookJson);&#10;&#10;        if (marketBookApiResponse?.Result?.Any() == true)&#10;        {&#10;            Console.WriteLine($&quot;MarketBookApiResponse contains {marketBookApiResponse.Result.Count} items.&quot;);&#10;            var marketBooks = marketBookApiResponse.Result&#10;                .Where(book =&gt; book.MarketId != null)&#10;                .Select(book =&gt; new MarketBook&lt;ApiRunner&gt;&#10;                {&#10;                    MarketId = book.MarketId,&#10;                    IsMarketDataDelayed = book.IsMarketDataDelayed,&#10;                    Status = book.Status,&#10;                    BetDelay = book.BetDelay,&#10;                    BspReconciled = book.BspReconciled,&#10;                    Complete = book.Complete,&#10;                    Inplay = book.Inplay,&#10;                    NumberOfWinners = book.NumberOfWinners,&#10;                    NumberOfRunners = book.NumberOfRunners,&#10;                    NumberOfActiveRunners = book.NumberOfActiveRunners,&#10;                    LastMatchTime = book.LastMatchTime,&#10;                    TotalMatched = book.TotalMatched,&#10;                    TotalAvailable = book.TotalAvailable,&#10;                    CrossMatching = book.CrossMatching,&#10;                    RunnersVoidable = book.RunnersVoidable,&#10;                    Version = book.Version,&#10;                    Runners = book.Runners?.Select(runner =&gt; new ApiRunner&#10;                    {&#10;                        SelectionId = runner.SelectionId,&#10;                        Handicap = runner.Handicap,&#10;                        Status = runner.Status,&#10;                        LastPriceTraded = runner.LastPriceTraded,&#10;                        TotalMatched = runner.TotalMatched,&#10;&#10;                        Exchange = runner.Exchange != null&#10;                            ? new Exchange&#10;                            {&#10;                                AvailableToBack = runner.Exchange.AvailableToBack?.Select(p =&gt; new PriceSize&#10;                                {&#10;                                    Price = p.Price,&#10;                                    Size = p.Size&#10;                                }).ToList() ?? new List&lt;PriceSize&gt;(),&#10;&#10;                                AvailableToLay = runner.Exchange.AvailableToLay?.Select(p =&gt; new PriceSize&#10;                                {&#10;                                    Price = p.Price,&#10;                                    Size = p.Size&#10;                                }).ToList() ?? new List&lt;PriceSize&gt;(),&#10;&#10;                                TradedVolume = runner.Exchange.TradedVolume?.Select(p =&gt; new PriceSize&#10;                                {&#10;                                    Price = p.Price,&#10;                                    Size = p.Size&#10;                                }).ToList() ?? new List&lt;PriceSize&gt;()&#10;                            }&#10;                            : null,&#10;                        Description = runner.Description&#10;                    }).ToList() ?? new List&lt;ApiRunner&gt;()&#10;                })&#10;                .ToList();&#10;&#10;            Console.WriteLine($&quot;Processed {marketBooks.Count} market books.&quot;);&#10;            foreach (var book in marketBooks)&#10;            {&#10;                Console.WriteLine($&quot;MarketId: {book.MarketId}, Runners: {book.Runners.Count}&quot;);&#10;                foreach (var runner in book.Runners)&#10;                {&#10;                    Console.WriteLine($&quot;RunnerId: {runner.SelectionId}, AvailableToBack: {runner.Exchange?.AvailableToBack?.Count}, AvailableToLay: {runner.Exchange?.AvailableToLay?.Count}&quot;);&#10;                }&#10;            }&#10;&#10;            if (marketBooks.Any())&#10;            {&#10;                await _marketBookDb.InsertMarketBooksIntoDatabase(marketBooks);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Console.WriteLine(&quot;MarketBookApiResponse is null or contains no results.&quot;);&#10;        }&#10;    }&#10;&#10;   public async Task&lt;List&lt;MarketDetails&gt;&gt; ProcessMarketCataloguesAsync(string eventId = null, string competitionId = null)&#10;{&#10;    var marketCatalogueJson = await _marketApiService.ListMarketCatalogue(eventId: eventId, competitionId: competitionId);&#10;    var marketCatalogueApiResponse = JsonSerializer.Deserialize&lt;ApiResponse&lt;MarketCatalogue&gt;&gt;(marketCatalogueJson);&#10;&#10;    if (marketCatalogueApiResponse == null)&#10;    {&#10;        //Console.WriteLine(&quot;Failed to deserialize the market catalogue JSON.&quot;);&#10;    }&#10;    else&#10;    {&#10;        //Console.WriteLine($&quot;Deserialized Result Count: {marketCatalogueApiResponse.Result?.Count()}&quot;);&#10;    }&#10;&#10;    var filteredMarketDetails = new List&lt;MarketDetails&gt;();&#10;&#10;    if (marketCatalogueApiResponse?.Result != null &amp;&amp; marketCatalogueApiResponse.Result.Any())&#10;    {&#10;        var marketCatalogues = marketCatalogueApiResponse.Result&#10;            .Where(catalogue =&gt; catalogue.Event != null)&#10;            .Select(catalogue =&gt; new MarketCatalogue&#10;            {&#10;                MarketId = catalogue.MarketId,&#10;                MarketName = catalogue.MarketName,&#10;                TotalMatched = catalogue.TotalMatched,&#10;                EventType = catalogue.EventType != null&#10;                    ? new EventType&#10;                    {&#10;                        Id = catalogue.EventType.Id,&#10;                        Name = catalogue.EventType.Name&#10;                    }&#10;                    : null,&#10;&#10;                Competition = catalogue.Competition != null&#10;                    ? new Competition&#10;                    {&#10;                        Id = catalogue.Competition.Id,&#10;                        Name = catalogue.Competition.Name&#10;                    }&#10;                    : null,&#10;&#10;                Event = catalogue.Event != null&#10;                    ? new Event&#10;                    {&#10;                        Id = catalogue.Event.Id,&#10;                        Name = catalogue.Event.Name,&#10;                        CountryCode = catalogue.Event.CountryCode,&#10;                        Timezone = catalogue.Event.Timezone,&#10;                        OpenDate = catalogue.Event.OpenDate&#10;                    }&#10;                    : null,&#10;&#10;                Runners = catalogue.Runners != null&#10;                    ? catalogue.Runners.Select(runner =&gt; new RunnerDescription&#10;                    {&#10;                        SelectionId = runner.SelectionId,&#10;                        RunnerName = runner.RunnerName,&#10;                        Metadata = runner.Metadata&#10;                    }).ToList()&#10;                    : new List&lt;RunnerDescription&gt;()&#10;            })&#10;            .Where(catalogue =&gt; catalogue.Event != null)&#10;            .ToList();&#10;&#10;        // Flatten all runners from all market catalogues using RunnerMapper&#10;        var allFlatRunners = marketCatalogues&#10;            .SelectMany(mc =&gt; mc.Runners)&#10;            .Select(runnerDesc =&gt; RunnerMapper.MapToFlat(runnerDesc))&#10;            .ToList();&#10;&#10;        //Console.WriteLine($&quot;Total runners flattened: {allFlatRunners.Count}&quot;);&#10;&#10;        // TODO: Insert flattened runners into database if you have a runner DB&#10;        // await _runnerDb.InsertRunnersAsync(allFlatRunners);&#10;&#10;        var today = DateTime.Now.Date;&#10;        filteredMarketDetails = marketCatalogues&#10;            .Where(catalogue =&gt; catalogue.Event.Id.Equals(eventId, StringComparison.OrdinalIgnoreCase)&#10;                                &amp;&amp; Regex.IsMatch(catalogue.MarketName, @&quot;^R\d{1,2}&quot;)&#10;                                &amp;&amp; catalogue.Event.OpenDate.HasValue&#10;                                &amp;&amp; catalogue.Event.OpenDate.Value.ToLocalTime().Date == today)&#10;            .Select(catalogue =&gt; new MarketDetails&#10;            {&#10;                MarketId = catalogue.MarketId,&#10;                MarketName = catalogue.MarketName&#10;            })&#10;            .ToList();&#10;&#10;        if (marketCatalogues.Any())&#10;        {&#10;            await _listMarketCatalogueDb.InsertMarketsIntoDatabase(marketCatalogues);&#10;        }&#10;        else&#10;        {&#10;            //Console.WriteLine(&quot;No market catalogues to insert.&quot;);&#10;        }&#10;    }&#10;    else&#10;    {&#10;        //Console.WriteLine(&quot;Failed to deserialize market catalogues or no market catalogues found.&quot;);&#10;    }&#10;&#10;    return filteredMarketDetails;&#10;}&#10;&#10;&#10;    public async Task&lt;List&lt;string&gt;&gt; ProcessNbaMarketCataloguesAsync(string eventId)&#10;    {&#10;        var marketCatalogueJson = await _marketApiService.ListMarketCatalogue(eventId);&#10;        var marketCatalogueApiResponse = JsonSerializer.Deserialize&lt;ApiResponse&lt;MarketCatalogue&gt;&gt;(marketCatalogueJson);&#10;&#10;        var filteredMarketIds = new List&lt;string&gt;();&#10;&#10;        if (marketCatalogueApiResponse?.Result != null &amp;&amp; marketCatalogueApiResponse.Result.Any())&#10;        {&#10;            var marketCatalogues = marketCatalogueApiResponse.Result&#10;                .Where(catalogue =&gt; catalogue.Event != null)&#10;                .Select(catalogue =&gt; new MarketCatalogue&#10;                {&#10;                    MarketId = catalogue.MarketId,&#10;                    MarketName = catalogue.MarketName,&#10;                    TotalMatched = catalogue.TotalMatched,&#10;                    EventType = catalogue.EventType != null&#10;                        ? new EventType&#10;                        {&#10;                            Id = catalogue.EventType.Id,&#10;                            Name = catalogue.EventType.Name&#10;                        }&#10;                        : null,&#10;&#10;                    Competition = catalogue.Competition != null&#10;                        ? new Competition&#10;                        {&#10;                            Id = catalogue.Competition.Id,&#10;                            Name = catalogue.Competition.Name&#10;                        }&#10;                        : null,&#10;&#10;                    Event = catalogue.Event != null&#10;                        ? new Event&#10;                        {&#10;                            Id = catalogue.Event.Id,&#10;                            Name = catalogue.Event.Name,&#10;                            CountryCode = catalogue.Event.CountryCode,&#10;                            Timezone = catalogue.Event.Timezone,&#10;                            OpenDate = catalogue.Event.OpenDate&#10;                        }&#10;                        : null,&#10;                    Runners = catalogue.Runners?.Select(runner =&gt; new RunnerDescription&#10;                    {&#10;                        SelectionId = runner.SelectionId,&#10;                        RunnerName = runner.RunnerName,&#10;                        Metadata = runner.Metadata&#10;                    }).ToList()&#10;                        ?? new List&lt;RunnerDescription&gt;()&#10;                })&#10;                .Where(catalogue =&gt; catalogue.Event != null)&#10;                .ToList();&#10;&#10;            filteredMarketIds = marketCatalogues&#10;                .Where(catalogue =&gt; catalogue.MarketName.Contains(&quot;Moneyline&quot;, StringComparison.OrdinalIgnoreCase))&#10;                .Select(catalogue =&gt; catalogue.MarketId)&#10;                .ToList();&#10;&#10;            if (marketCatalogues.Any())&#10;            {&#10;                await _listMarketCatalogueDb.InsertMarketsIntoDatabase(marketCatalogues);&#10;            }&#10;            else&#10;            {&#10;                //Console.WriteLine(&quot;No market catalogues to insert.&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            //Console.WriteLine(&quot;Failed to deserialize market catalogues or no market catalogues found.&quot;);&#10;        }&#10;&#10;        //Console.WriteLine($&quot;Filtered Market Ids: {filteredMarketIds.Count}&quot;);&#10;        return filteredMarketIds;&#10;    }&#10;&#10;    public async Task FetchAndStoreMarketProfitAndLossAsync(List&lt;string&gt; marketIds)&#10;    {&#10;        try&#10;        {&#10;            await _marketApiService.ProcessAndStoreMarketProfitAndLoss(marketIds);&#10;&#10;            //Console.WriteLine(&quot;Market Profit and Loss data fetched and stored successfully.&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            //Console.WriteLine($&quot;Failed to fetch and store Market Profit and Loss data: {ex.Message}&quot;);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Text.Json;&#10;using System.Text.RegularExpressions;&#10;using Betfair.Data;&#10;using Betfair.Mappers;&#10;using Betfair.Models;&#10;using Betfair.Models.Competition;&#10;using Betfair.Models.Event;&#10;using Betfair.Models.Market;&#10;using Betfair.Models.Runner;&#10;using Betfair.Services;&#10;&#10;namespace Betfair.AutomationServices;&#10;&#10;public class MarketDetails&#10;{&#10;    public string MarketId { get; set; }&#10;    public string MarketName { get; set; }&#10;}&#10;&#10;public class MarketAutomationService&#10;{&#10;    private readonly IMarketApiService _marketApiService;&#10;    private readonly ListMarketCatalogueDb _listMarketCatalogueDb;&#10;    private readonly MarketBookDb _marketBookDb;&#10;&#10;    public MarketAutomationService(IMarketApiService marketApiService, ListMarketCatalogueDb listMarketCatalogueDb, MarketBookDb marketBookDb)&#10;    {&#10;        _marketApiService = marketApiService;&#10;        _listMarketCatalogueDb = listMarketCatalogueDb;&#10;        _marketBookDb = marketBookDb;&#10;    }&#10;&#10;    public async Task ProcessMarketBooksAsync(List&lt;string&gt; marketIds)&#10;    {&#10;        Console.WriteLine($&quot; ProcessMarketBooksAsync called with {marketIds?.Count ?? 0} market IDs&quot;);&#10;        &#10;        if (marketIds == null || !marketIds.Any())&#10;        {&#10;            Console.WriteLine(&quot;❌ No market IDs provided to ProcessMarketBooksAsync - returning early&quot;);&#10;            return;&#10;        }&#10;&#10;        Console.WriteLine($&quot; Market IDs to process: [{string.Join(&quot;, &quot;, marketIds)}]&quot;);&#10;&#10;        var marketBookJson = await _marketApiService.ListMarketBookAsync(marketIds);&#10;        Console.WriteLine($&quot; Received market book JSON: {(!string.IsNullOrEmpty(marketBookJson) ? &quot;Data received&quot; : &quot;No data&quot;)}&quot;);&#10;&#10;        var marketBookApiResponse = JsonSerializer.Deserialize&lt;ApiResponse&lt;MarketBook&lt;ApiRunner&gt;&gt;&gt;(marketBookJson);&#10;        Console.WriteLine($&quot; Deserialization result: {marketBookApiResponse?.Result?.Count() ?? 0} market books&quot;);&#10;&#10;        if (marketBookApiResponse?.Result?.Any() == true)&#10;        {&#10;            var marketBooks = marketBookApiResponse.Result&#10;                .Where(book =&gt; book.MarketId != null)&#10;                .Select(book =&gt; new MarketBook&lt;ApiRunner&gt;&#10;                {&#10;                    MarketId = book.MarketId,&#10;                    IsMarketDataDelayed = book.IsMarketDataDelayed,&#10;                    Status = book.Status,&#10;                    BetDelay = book.BetDelay,&#10;                    BspReconciled = book.BspReconciled,&#10;                    Complete = book.Complete,&#10;                    Inplay = book.Inplay,&#10;                    NumberOfWinners = book.NumberOfWinners,&#10;                    NumberOfRunners = book.NumberOfRunners,&#10;                    NumberOfActiveRunners = book.NumberOfActiveRunners,&#10;                    LastMatchTime = book.LastMatchTime,&#10;                    TotalMatched = book.TotalMatched,&#10;                    TotalAvailable = book.TotalAvailable,&#10;                    CrossMatching = book.CrossMatching,&#10;                    RunnersVoidable = book.RunnersVoidable,&#10;                    Version = book.Version,&#10;                    Runners = book.Runners?.Select(runner =&gt; new ApiRunner&#10;                    {&#10;                        SelectionId = runner.SelectionId,&#10;                        Handicap = runner.Handicap,&#10;                        Status = runner.Status,&#10;                        LastPriceTraded = runner.LastPriceTraded,&#10;                        TotalMatched = runner.TotalMatched,&#10;&#10;                        Exchange = runner.Exchange != null&#10;                            ? new Exchange&#10;                            {&#10;                                AvailableToBack = runner.Exchange.AvailableToBack?.Select(p =&gt; new PriceSize&#10;                                {&#10;                                    Price = p.Price,&#10;                                    Size = p.Size&#10;                                }).ToList() ?? new List&lt;PriceSize&gt;(),&#10;&#10;                                AvailableToLay = runner.Exchange.AvailableToLay?.Select(p =&gt; new PriceSize&#10;                                {&#10;                                    Price = p.Price,&#10;                                    Size = p.Size&#10;                                }).ToList() ?? new List&lt;PriceSize&gt;(),&#10;&#10;                                TradedVolume = runner.Exchange.TradedVolume?.Select(p =&gt; new PriceSize&#10;                                {&#10;                                    Price = p.Price,&#10;                                    Size = p.Size&#10;                                }).ToList() ?? new List&lt;PriceSize&gt;()&#10;                            }&#10;                            : null,&#10;                        Description = runner.Description&#10;                    }).ToList() ?? new List&lt;ApiRunner&gt;()&#10;                })&#10;                .ToList();&#10;&#10;            Console.WriteLine($&quot; Processed {marketBooks.Count} market books with exchange data&quot;);&#10;            &#10;            // Log details about exchange data&#10;            foreach (var book in marketBooks)&#10;            {&#10;                var runnersWithExchange = book.Runners?.Count(r =&gt; r.Exchange != null) ?? 0;&#10;                var totalBackPrices = book.Runners?.Sum(r =&gt; r.Exchange?.AvailableToBack?.Count ?? 0) ?? 0;&#10;                var totalLayPrices = book.Runners?.Sum(r =&gt; r.Exchange?.AvailableToLay?.Count ?? 0) ?? 0;&#10;                &#10;                Console.WriteLine($&quot; Market {book.MarketId}: {runnersWithExchange} runners with exchange data, {totalBackPrices} back prices, {totalLayPrices} lay prices&quot;);&#10;            }&#10;&#10;            if (marketBooks.Any())&#10;            {&#10;                Console.WriteLine($&quot; Calling InsertMarketBooksIntoDatabase with {marketBooks.Count} market books&quot;);&#10;                await _marketBookDb.InsertMarketBooksIntoDatabase(marketBooks);&#10;                Console.WriteLine($&quot;✅ InsertMarketBooksIntoDatabase completed&quot;);&#10;            }&#10;            else&#10;            {&#10;                Console.WriteLine(&quot;❌ No market books to insert after processing&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Console.WriteLine(&quot;❌ Failed to deserialize market book or no market book data found&quot;);&#10;        }&#10;    }&#10;&#10;   public async Task&lt;List&lt;MarketDetails&gt;&gt; ProcessMarketCataloguesAsync(string eventId = null, string competitionId = null)&#10;{&#10;    var marketCatalogueJson = await _marketApiService.ListMarketCatalogue(eventId: eventId, competitionId: competitionId);&#10;    var marketCatalogueApiResponse = JsonSerializer.Deserialize&lt;ApiResponse&lt;MarketCatalogue&gt;&gt;(marketCatalogueJson);&#10;&#10;    if (marketCatalogueApiResponse == null)&#10;    {&#10;        //Console.WriteLine(&quot;Failed to deserialize the market catalogue JSON.&quot;);&#10;    }&#10;    else&#10;    {&#10;        //Console.WriteLine($&quot;Deserialized Result Count: {marketCatalogueApiResponse.Result?.Count()}&quot;);&#10;    }&#10;&#10;    var filteredMarketDetails = new List&lt;MarketDetails&gt;();&#10;&#10;    if (marketCatalogueApiResponse?.Result != null &amp;&amp; marketCatalogueApiResponse.Result.Any())&#10;    {&#10;        var marketCatalogues = marketCatalogueApiResponse.Result&#10;            .Where(catalogue =&gt; catalogue.Event != null)&#10;            .Select(catalogue =&gt; new MarketCatalogue&#10;            {&#10;                MarketId = catalogue.MarketId,&#10;                MarketName = catalogue.MarketName,&#10;                TotalMatched = catalogue.TotalMatched,&#10;                EventType = catalogue.EventType != null&#10;                    ? new EventType&#10;                    {&#10;                        Id = catalogue.EventType.Id,&#10;                        Name = catalogue.EventType.Name&#10;                    }&#10;                    : null,&#10;&#10;                Competition = catalogue.Competition != null&#10;                    ? new Competition&#10;                    {&#10;                        Id = catalogue.Competition.Id,&#10;                        Name = catalogue.Competition.Name&#10;                    }&#10;                    : null,&#10;&#10;                Event = catalogue.Event != null&#10;                    ? new Event&#10;                    {&#10;                        Id = catalogue.Event.Id,&#10;                        Name = catalogue.Event.Name,&#10;                        CountryCode = catalogue.Event.CountryCode,&#10;                        Timezone = catalogue.Event.Timezone,&#10;                        OpenDate = catalogue.Event.OpenDate&#10;                    }&#10;                    : null,&#10;&#10;                Runners = catalogue.Runners != null&#10;                    ? catalogue.Runners.Select(runner =&gt; new RunnerDescription&#10;                    {&#10;                        SelectionId = runner.SelectionId,&#10;                        RunnerName = runner.RunnerName,&#10;                        Metadata = runner.Metadata&#10;                    }).ToList()&#10;                    : new List&lt;RunnerDescription&gt;()&#10;            })&#10;            .Where(catalogue =&gt; catalogue.Event != null)&#10;            .ToList();&#10;&#10;        // Flatten all runners from all market catalogues using RunnerMapper&#10;        var allFlatRunners = marketCatalogues&#10;            .SelectMany(mc =&gt; mc.Runners)&#10;            .Select(runnerDesc =&gt; RunnerMapper.MapToFlat(runnerDesc))&#10;            .ToList();&#10;&#10;        //Console.WriteLine($&quot;Total runners flattened: {allFlatRunners.Count}&quot;);&#10;&#10;        // TODO: Insert flattened runners into database if you have a runner DB&#10;        // await _runnerDb.InsertRunnersAsync(allFlatRunners);&#10;&#10;        var today = DateTime.Now.Date;&#10;        filteredMarketDetails = marketCatalogues&#10;            .Where(catalogue =&gt; catalogue.Event.Id.Equals(eventId, StringComparison.OrdinalIgnoreCase)&#10;                                &amp;&amp; Regex.IsMatch(catalogue.MarketName, @&quot;^R\d{1,2}&quot;)&#10;                                &amp;&amp; catalogue.Event.OpenDate.HasValue&#10;                                &amp;&amp; catalogue.Event.OpenDate.Value.ToLocalTime().Date == today)&#10;            .Select(catalogue =&gt; new MarketDetails&#10;            {&#10;                MarketId = catalogue.MarketId,&#10;                MarketName = catalogue.MarketName&#10;            })&#10;            .ToList();&#10;&#10;        if (marketCatalogues.Any())&#10;        {&#10;            await _listMarketCatalogueDb.InsertMarketsIntoDatabase(marketCatalogues);&#10;        }&#10;        else&#10;        {&#10;            //Console.WriteLine(&quot;No market catalogues to insert.&quot;);&#10;        }&#10;    }&#10;    else&#10;    {&#10;        //Console.WriteLine(&quot;Failed to deserialize market catalogues or no market catalogues found.&quot;);&#10;    }&#10;&#10;    return filteredMarketDetails;&#10;}&#10;&#10;&#10;    public async Task&lt;List&lt;string&gt;&gt; ProcessNbaMarketCataloguesAsync(string eventId)&#10;    {&#10;        var marketCatalogueJson = await _marketApiService.ListMarketCatalogue(eventId);&#10;        var marketCatalogueApiResponse = JsonSerializer.Deserialize&lt;ApiResponse&lt;MarketCatalogue&gt;&gt;(marketCatalogueJson);&#10;&#10;        var filteredMarketIds = new List&lt;string&gt;();&#10;&#10;        if (marketCatalogueApiResponse?.Result != null &amp;&amp; marketCatalogueApiResponse.Result.Any())&#10;        {&#10;            var marketCatalogues = marketCatalogueApiResponse.Result&#10;                .Where(catalogue =&gt; catalogue.Event != null)&#10;                .Select(catalogue =&gt; new MarketCatalogue&#10;                {&#10;                    MarketId = catalogue.MarketId,&#10;                    MarketName = catalogue.MarketName,&#10;                    TotalMatched = catalogue.TotalMatched,&#10;                    EventType = catalogue.EventType != null&#10;                        ? new EventType&#10;                        {&#10;                            Id = catalogue.EventType.Id,&#10;                            Name = catalogue.EventType.Name&#10;                        }&#10;                        : null,&#10;&#10;                    Competition = catalogue.Competition != null&#10;                        ? new Competition&#10;                        {&#10;                            Id = catalogue.Competition.Id,&#10;                            Name = catalogue.Competition.Name&#10;                        }&#10;                        : null,&#10;&#10;                    Event = catalogue.Event != null&#10;                        ? new Event&#10;                        {&#10;                            Id = catalogue.Event.Id,&#10;                            Name = catalogue.Event.Name,&#10;                            CountryCode = catalogue.Event.CountryCode,&#10;                            Timezone = catalogue.Event.Timezone,&#10;                            OpenDate = catalogue.Event.OpenDate&#10;                        }&#10;                        : null,&#10;                    Runners = catalogue.Runners?.Select(runner =&gt; new RunnerDescription&#10;                    {&#10;                        SelectionId = runner.SelectionId,&#10;                        RunnerName = runner.RunnerName,&#10;                        Metadata = runner.Metadata&#10;                    }).ToList()&#10;                        ?? new List&lt;RunnerDescription&gt;()&#10;                })&#10;                .Where(catalogue =&gt; catalogue.Event != null)&#10;                .ToList();&#10;&#10;            filteredMarketIds = marketCatalogues&#10;                .Where(catalogue =&gt; catalogue.MarketName.Contains(&quot;Moneyline&quot;, StringComparison.OrdinalIgnoreCase))&#10;                .Select(catalogue =&gt; catalogue.MarketId)&#10;                .ToList();&#10;&#10;            if (marketCatalogues.Any())&#10;            {&#10;                await _listMarketCatalogueDb.InsertMarketsIntoDatabase(marketCatalogues);&#10;            }&#10;            else&#10;            {&#10;                //Console.WriteLine(&quot;No market catalogues to insert.&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            //Console.WriteLine(&quot;Failed to deserialize market catalogues or no market catalogues found.&quot;);&#10;        }&#10;&#10;        //Console.WriteLine($&quot;Filtered Market Ids: {filteredMarketIds.Count}&quot;);&#10;        return filteredMarketIds;&#10;    }&#10;&#10;    public async Task FetchAndStoreMarketProfitAndLossAsync(List&lt;string&gt; marketIds)&#10;    {&#10;        try&#10;        {&#10;            await _marketApiService.ProcessAndStoreMarketProfitAndLoss(marketIds);&#10;&#10;            //Console.WriteLine(&quot;Market Profit and Loss data fetched and stored successfully.&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            //Console.WriteLine($&quot;Failed to fetch and store Market Profit and Loss data: {ex.Message}&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Betfair/Data/MarketBookDb.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Betfair/Data/MarketBookDb.cs" />
              <option name="originalContent" value="using System.Text.Json;&#10;using Microsoft.Data.Sqlite;&#10;using Betfair.Models.Market;&#10;using Betfair.Models.Runner;&#10;using Dapper;&#10;&#10;namespace Betfair.Data;&#10;&#10;public class MarketInfo&#10;{&#10;    public string? MarketName { get; set; }&#10;    public string? EventName { get; set; }&#10;&#10;    public void Deconstruct(out string? marketName, out string? eventName)&#10;    {&#10;        marketName = MarketName;&#10;        eventName = EventName;&#10;    }&#10;}&#10;&#10;public class MarketBookDb&#10;{&#10;    private readonly string _connectionString;&#10;&#10;    public MarketBookDb(string connectionString)&#10;    {&#10;        _connectionString = connectionString;&#10;        try&#10;        {&#10;            VerifyHorseMarketBookSchema();&#10;        }&#10;        catch (Exception)&#10;        {&#10;            // Log or handle initialization errors if necessary&#10;        }&#10;    }&#10;&#10;    private void VerifyHorseMarketBookSchema()&#10;    {&#10;        using var connection = new SqliteConnection(_connectionString);&#10;        connection.Open();&#10;        var cmd = connection.CreateCommand();&#10;        cmd.CommandText = &quot;PRAGMA table_info(HorseMarketBook);&quot;;&#10;&#10;        using var reader = cmd.ExecuteReader();&#10;        while (reader.Read())&#10;        {&#10;            string colName = reader.GetString(1);&#10;            if (colName.Equals(&quot;DAM_YEAR_BORN&quot;, StringComparison.OrdinalIgnoreCase))&#10;            {&#10;                // Column exists, no further action needed&#10;            }&#10;        }&#10;    }&#10;    public async Task InsertHorseMarketBooksIntoDatabase(List&lt;MarketBook&lt;RunnerFlat&gt;&gt; marketBooks)&#10;{&#10;    Console.WriteLine($&quot; InsertHorseMarketBooksIntoDatabase called with {marketBooks?.Count ?? 0} market books&quot;);&#10;    &#10;    if (marketBooks == null || !marketBooks.Any())&#10;    {&#10;        Console.WriteLine(&quot;❌ No market books provided - returning early&quot;);&#10;        return;&#10;    }&#10;&#10;    using var connection = new SqliteConnection(_connectionString);&#10;    await connection.OpenAsync();&#10;    using var transaction = await connection.BeginTransactionAsync();&#10;&#10;    int successfulRunnerInserts = 0;&#10;    int skippedMarketBooks = 0;&#10;&#10;    try&#10;    {&#10;        foreach (var marketBook in marketBooks)&#10;        {&#10;            string marketId = marketBook.MarketId;&#10;            Console.WriteLine($&quot; Processing market: {marketId}&quot;);&#10;&#10;            if (string.IsNullOrEmpty(marketId))&#10;            {&#10;                Console.WriteLine(&quot;⚠️ Skipping market with empty MarketId&quot;);&#10;                skippedMarketBooks++;&#10;                continue;&#10;            }&#10;&#10;            Console.WriteLine($&quot; Processing market: {marketId} with {marketBook.Runners?.Count ?? 0} runners&quot;);&#10;&#10;            var marketInfo = await GetMarketNameAndEventNameByMarketId(connection, marketId);&#10;            string marketName = marketInfo?.MarketName ?? &quot;Unknown&quot;;&#10;&#10;            foreach (var runner in marketBook.Runners)&#10;            {&#10;                if (runner.SelectionId == null)&#10;                {&#10;                    Console.WriteLine(&quot;⚠️ Skipping runner with null SelectionId&quot;);&#10;                    continue;&#10;                }&#10;&#10;                // Check if this specific horse already exists&#10;                var existingHorse = await connection.ExecuteScalarAsync&lt;int&gt;(&#10;                    &quot;SELECT COUNT(1) FROM HorseMarketBook WHERE MarketId = @MarketId AND SelectionId = @SelectionId&quot;,&#10;                    new { MarketId = marketId, SelectionId = runner.SelectionId });&#10;&#10;                if (existingHorse &gt; 0)&#10;                {&#10;                    // Delete this specific horse's old record&#10;                    await DeleteExistingHorseRecord(connection, marketId, runner.SelectionId);&#10;                    Console.WriteLine($&quot; Replacing existing data for horse {runner.SelectionId} in market {marketId}&quot;);&#10;                }&#10;&#10;                // Log the OwnerName for debugging purposes&#10;                Console.WriteLine($&quot;✅ Inserting Runner: SelectionId={runner.SelectionId}, Name={runner.RunnerName}, OwnerName={runner.OwnerName}&quot;);&#10;&#10;                var paramValues = new Dictionary&lt;string, object?&gt;&#10;                {&#10;                    [&quot;MarketId&quot;] = marketId,&#10;                    [&quot;MarketName&quot;] = marketName,&#10;                    [&quot;EventName&quot;] = marketInfo?.EventName ?? &quot;Unknown&quot;,&#10;                    [&quot;SelectionId&quot;] = runner.SelectionId,&#10;                    [&quot;RunnerName&quot;] = runner.RunnerName,&#10;                    [&quot;Status&quot;] = runner.Status,&#10;                    [&quot;SIRE_NAME&quot;] = runner.SireName,&#10;                    [&quot;CLOTH_NUMBER_ALPHA&quot;] = runner.ClothNumberAlpha,&#10;                    [&quot;OFFICIAL_RATING&quot;] = ParseNullableDouble(runner.OfficialRating),&#10;                    [&quot;COLOURS_DESCRIPTION&quot;] = runner.ColoursDescription,&#10;                    [&quot;COLOURS_FILENAME&quot;] = runner.ColoursFilename,&#10;                    [&quot;FORECASTPRICE_DENOMINATOR&quot;] = ParseNullableInt(runner.ForecastPriceDenominator),&#10;                    [&quot;DAMSIRE_NAME&quot;] = runner.DamsireName,&#10;                    [&quot;WEIGHT_VALUE&quot;] = ParseNullableDouble(runner.WeightValue),&#10;                    [&quot;SEX_TYPE&quot;] = runner.SexType,&#10;                    [&quot;DAYS_SINCE_LAST_RUN&quot;] = ParseNullableInt(runner.DaysSinceLastRun),&#10;                    [&quot;WEARING&quot;] = runner.Wearing,&#10;                    [&quot;OWNER_NAME&quot;] = runner.OwnerName,&#10;                    [&quot;DAM_YEAR_BORN&quot;] = ParseNullableInt(runner.DamYearBorn),&#10;                    [&quot;SIRE_BRED&quot;] = runner.SireBred,&#10;                    [&quot;JOCKEY_NAME&quot;] = runner.JockeyName,&#10;                    [&quot;DAM_BRED&quot;] = runner.DamBred,&#10;                    [&quot;ADJUSTED_RATING&quot;] = ParseNullableDouble(runner.AdjustedRating),&#10;                    [&quot;CLOTH_NUMBER&quot;] = runner.ClothNumber,&#10;                    [&quot;SIRE_YEAR_BORN&quot;] = ParseNullableInt(runner.SireYearBorn),&#10;                    [&quot;TRAINER_NAME&quot;] = runner.TrainerName,&#10;                    [&quot;COLOUR_TYPE&quot;] = runner.ColourType,&#10;                    [&quot;AGE&quot;] = ParseNullableInt(runner.Age),&#10;                    [&quot;DAMSIRE_BRED&quot;] = runner.DamsireBred,&#10;                    [&quot;JOCKEY_CLAIM&quot;] = ParseNullableDouble(runner.JockeyClaim),&#10;                    [&quot;FORM&quot;] = runner.Form,&#10;                    [&quot;FORECASTPRICE_NUMERATOR&quot;] = ParseNullableInt(runner.ForecastPriceNumerator),&#10;                    [&quot;BRED&quot;] = runner.Bred,&#10;                    [&quot;DAM_NAME&quot;] = runner.DamName,&#10;                    [&quot;DAMSIRE_YEAR_BORN&quot;] = ParseNullableInt(runner.DamsireYearBorn),&#10;                    [&quot;STALL_DRAW&quot;] = ParseNullableInt(runner.StallDraw),&#10;                    [&quot;WEIGHT_UNITS&quot;] = runner.WeightUnits&#10;                };&#10;&#10;                using var command = connection.CreateCommand();&#10;                command.CommandText = @&quot;&#10;                INSERT INTO HorseMarketBook (&#10;                    MarketId, MarketName, EventName, SelectionId, RUNNER_NAME, Status,&#10;                    SIRE_NAME, STALL_DRAW, DAMSIRE_NAME, FORM, WEIGHT_VALUE,&#10;                    SEX_TYPE, DAYS_SINCE_LAST_RUN, WEARING, OWNER_NAME, DAM_YEAR_BORN,&#10;                    SIRE_BRED, JOCKEY_NAME, DAM_BRED, CLOTH_NUMBER, SIRE_YEAR_BORN,&#10;                    TRAINER_NAME, COLOUR_TYPE, AGE, DAMSIRE_BRED, JOCKEY_CLAIM,&#10;                    FORECASTPRICE_NUMERATOR, BRED, DAM_NAME, DAMSIRE_YEAR_BORN, WEIGHT_UNITS,&#10;                    CLOTH_NUMBER_ALPHA, OFFICIAL_RATING, COLOURS_DESCRIPTION, COLOURS_FILENAME,&#10;                    FORECASTPRICE_DENOMINATOR&#10;                ) VALUES (&#10;                    $MarketId, $MarketName, $EventName, $SelectionId, $RunnerName, $Status,&#10;                    $SIRE_NAME, $STALL_DRAW, $DAMSIRE_NAME, $FORM, $WEIGHT_VALUE,&#10;                    $SEX_TYPE, $DAYS_SINCE_LAST_RUN, $WEARING, $OWNER_NAME, $DAM_YEAR_BORN,&#10;                    $SIRE_BRED, $JOCKEY_NAME, $DAM_BRED, $CLOTH_NUMBER, $SIRE_YEAR_BORN,&#10;                    $TRAINER_NAME, $COLOUR_TYPE, $AGE, $DAMSIRE_BRED, $JOCKEY_CLAIM,&#10;                    $FORECASTPRICE_NUMERATOR, $BRED, $DAM_NAME, $DAMSIRE_YEAR_BORN, $WEIGHT_UNITS,&#10;                    $CLOTH_NUMBER_ALPHA, $OFFICIAL_RATING, $COLOURS_DESCRIPTION, $COLOURS_FILENAME,&#10;                    $FORECASTPRICE_DENOMINATOR&#10;                )&quot;;&#10;&#10;                foreach (var kvp in paramValues)&#10;                {&#10;                    command.Parameters.AddWithValue($&quot;${kvp.Key}&quot;, kvp.Value ?? (object)DBNull.Value);&#10;                }&#10;&#10;                await command.ExecuteNonQueryAsync();&#10;                successfulRunnerInserts++;&#10;            }&#10;        }&#10;&#10;        await transaction.CommitAsync();&#10;        Console.WriteLine($&quot;✅ Successfully processed {successfulRunnerInserts} runners across {marketBooks.Count} market books.&quot;);&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        Console.WriteLine($&quot;❌ Error inserting horse market books: {ex.Message}&quot;);&#10;        Console.WriteLine($&quot;Stack trace: {ex.StackTrace}&quot;);&#10;        await transaction.RollbackAsync();&#10;    }&#10;}&#10;&#10;    public async Task InsertMarketBooksIntoDatabase(List&lt;MarketBook&lt;ApiRunner&gt;&gt; marketBooks)&#10;    {&#10;        using var connection = new SqliteConnection(_connectionString);&#10;        await connection.OpenAsync();&#10;        Console.WriteLine(new string('*', 215));&#10;&#10;        using var transaction = await connection.BeginTransactionAsync();&#10;&#10;        await DeleteExistingData(connection, new List&lt;string&gt; { &quot;MarketBookBackPrices&quot;, &quot;MarketBookLayPrices&quot; });&#10;        await ResetAutoIncrementCounters(connection, new List&lt;string&gt; { &quot;MarketBookBackPrices&quot;, &quot;MarketBookLayPrices&quot; });&#10;&#10;        try&#10;        {&#10;            foreach (var marketBook in marketBooks)&#10;            {&#10;                string marketId = marketBook.MarketId;&#10;&#10;                foreach (var runner in marketBook.Runners)&#10;                {&#10;                    if (runner.Exchange != null)&#10;                    {&#10;                        foreach (var back in runner.Exchange.AvailableToBack)&#10;                        {&#10;                            if (await IsDataExist(connection, &quot;MarketBookBackPrices&quot;, marketId, runner.SelectionId, back.Price))&#10;                            {&#10;                               //Console.WriteLine($&quot;Skipping duplicate Back bet data for Runner {runner.SelectionId}: Price = {back.Price}&quot;);&#10;                                continue;&#10;                            }&#10;&#10;                            using var priceCommand = connection.CreateCommand();&#10;                            priceCommand.CommandText = @&quot;&#10;                                INSERT INTO MarketBookBackPrices&#10;                                (MarketId, SelectionId, Price, Size, Status, LastPriceTraded, TotalMatched)&#10;                                VALUES&#10;                                ($MarketId, $SelectionId, $Price, $Size, $Status, $LastPriceTraded, $TotalMatched)&quot;;&#10;&#10;                            priceCommand.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Price&quot;, (double)back.Price);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Size&quot;, (double)back.Size);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$LastPriceTraded&quot;, runner.LastPriceTraded ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$TotalMatched&quot;, runner.TotalMatched ?? (object)DBNull.Value);&#10;&#10;                            await priceCommand.ExecuteNonQueryAsync();&#10;                        }&#10;&#10;                        foreach (var lay in runner.Exchange.AvailableToLay)&#10;                        {&#10;                            if (await IsDataExist(connection, &quot;MarketBookLayPrices&quot;, marketId, runner.SelectionId, lay.Price))&#10;                            {&#10;                               //Console.WriteLine($&quot;Skipping duplicate Lay bet data for Runner {runner.SelectionId}: Price = {lay.Price}&quot;);&#10;                                continue;&#10;                            }&#10;&#10;                            using var priceCommand = connection.CreateCommand();&#10;                            priceCommand.CommandText = @&quot;&#10;                                INSERT INTO MarketBookLayPrices&#10;                                (MarketId, SelectionId, Price, Size, Status, LastPriceTraded, TotalMatched)&#10;                                VALUES&#10;                                ($MarketId, $SelectionId, $Price, $Size, $Status, $LastPriceTraded, $TotalMatched)&quot;;&#10;&#10;                            priceCommand.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Price&quot;, (double)lay.Price);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Size&quot;, (double)lay.Size);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$LastPriceTraded&quot;, runner.LastPriceTraded ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$TotalMatched&quot;, runner.TotalMatched ?? (object)DBNull.Value);&#10;&#10;                            await priceCommand.ExecuteNonQueryAsync();&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            await transaction.CommitAsync();&#10;           //Console.WriteLine(&quot;Market book back/lay prices inserted successfully.&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            await transaction.RollbackAsync();&#10;           //Console.WriteLine($&quot;Error inserting market book prices: {ex.Message}&quot;);&#10;           //Console.WriteLine(ex.ToString());&#10;        }&#10;    }&#10;&#10;&#10;    public async Task InsertGreyhoundMarketBooksIntoDatabase(List&lt;MarketBook&lt;ApiRunner&gt;&gt; marketBooks)&#10;    {&#10;        using var connection = new SqliteConnection(_connectionString);&#10;        await connection.OpenAsync();&#10;        using var transaction = await connection.BeginTransactionAsync();&#10;&#10;        try&#10;        {&#10;            foreach (var marketBook in marketBooks)&#10;            {&#10;                string marketId = marketBook.MarketId;&#10;                var marketInfo = await GetMarketNameAndEventNameByMarketId(connection, marketId);&#10;&#10;                foreach (var runner in marketBook.Runners)&#10;                {&#10;                    if (runner.Exchange?.AvailableToBack != null)&#10;                    {&#10;                        foreach (var back in runner.Exchange.AvailableToBack)&#10;                        {&#10;                            using var command = connection.CreateCommand();&#10;                            command.CommandText = @&quot;&#10;                                INSERT INTO GreyhoundMarketBook&#10;                                (MarketId, MarketName, SelectionId, Status, PriceType, Price, Size)&#10;                                VALUES&#10;                                ($MarketId, $MarketName, $SelectionId, $Status, $PriceType, $Price, $Size)&quot;;&#10;&#10;                            command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$MarketName&quot;, marketInfo?.MarketName ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            command.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$PriceType&quot;, &quot;AvailableToBack&quot;);&#10;                            command.Parameters.AddWithValue(&quot;$Price&quot;, (double)back.Price);&#10;                            command.Parameters.AddWithValue(&quot;$Size&quot;, (double)back.Size);&#10;&#10;                            await command.ExecuteNonQueryAsync();&#10;                        }&#10;                    }&#10;&#10;                    if (runner.Exchange?.AvailableToLay != null)&#10;                    {&#10;                        foreach (var lay in runner.Exchange.AvailableToLay)&#10;                        {&#10;                            using var command = connection.CreateCommand();&#10;                            command.CommandText = @&quot;&#10;                                INSERT INTO GreyhoundMarketBook&#10;                                (MarketId, MarketName, SelectionId, Status, PriceType, Price, Size)&#10;                                VALUES&#10;                                ($MarketId, $MarketName, $SelectionId, $Status, $PriceType, $Price, $Size)&quot;;&#10;&#10;                            command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$MarketName&quot;, marketInfo?.MarketName ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            command.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$PriceType&quot;, &quot;AvailableToLay&quot;);&#10;                            command.Parameters.AddWithValue(&quot;$Price&quot;, (double)lay.Price);&#10;                            command.Parameters.AddWithValue(&quot;$Size&quot;, (double)lay.Size);&#10;&#10;                            await command.ExecuteNonQueryAsync();&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            await transaction.CommitAsync();&#10;            //Console.WriteLine(&quot;Greyhound market books inserted successfully.&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            await transaction.RollbackAsync();&#10;            //Console.WriteLine($&quot;Error inserting greyhound market books: {ex.Message}&quot;);&#10;            //Console.WriteLine(ex.ToString());&#10;        }&#10;    }&#10;&#10;    public async Task&lt;List&lt;HorseMarketBook&gt;&gt; GetHorseMarketBooksAsync()&#10;{&#10;    using var connection = new SqliteConnection(_connectionString);&#10;    await connection.OpenAsync();&#10;&#10;    var query = @&quot;SELECT MarketId, MarketName, EventName, SelectionId, RUNNER_NAME as RunnerName, Status, SIRE_NAME as SireName, DAMSIRE_NAME as DamsireName, TRAINER_NAME as TrainerName, AGE, WEIGHT_VALUE as WeightValue, COLOUR_TYPE as ColourType, FORM FROM HorseMarketBook&quot;;&#10;    var result = await connection.QueryAsync&lt;HorseMarketBook&gt;(query);&#10;&#10;    return result.ToList();&#10;}&#10;&#10;    private async Task&lt;MarketInfo&gt; GetMarketNameAndEventNameByMarketId(SqliteConnection connection, string marketId)&#10;    {&#10;        using var command = connection.CreateCommand();&#10;        command.CommandText = @&quot;&#10;        SELECT MarketName, EventName&#10;        FROM EventMarkets&#10;        WHERE MarketId = $MarketId&#10;        LIMIT 1&quot;;&#10;        command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId);&#10;&#10;        using var reader = await command.ExecuteReaderAsync();&#10;        if (await reader.ReadAsync())&#10;        {&#10;            return new MarketInfo&#10;            {&#10;                MarketName = reader.GetString(0),&#10;                EventName = reader.GetString(1)&#10;            };&#10;        }&#10;&#10;        Console.WriteLine($&quot;No matching MarketId found in EventMarkets for MarketId: {marketId}&quot;);&#10;        return new MarketInfo { MarketName = &quot;Unknown&quot;, EventName = &quot;Unknown&quot; };&#10;    }&#10;&#10;    private static int? ParseNullableInt(string input) =&gt;&#10;        int.TryParse(input, out var result) ? result : null;&#10;&#10;    private static double? ParseNullableDouble(string input) =&gt;&#10;        double.TryParse(input, out var result) ? result : null;&#10;&#10;    private async Task DeleteExistingData(SqliteConnection connection, List&lt;string&gt; tableNames)&#10;    {&#10;        // Method removed as per request to avoid deletion logic.&#10;    }&#10;&#10;    private async Task&lt;bool&gt; IsDataExist(SqliteConnection connection, string tableName, object marketId, object selectionId, object price)&#10;    {&#10;        using var command = connection.CreateCommand();&#10;        command.CommandText = $@&quot;&#10;        SELECT COUNT(1)&#10;        FROM {tableName}&#10;        WHERE MarketId = $MarketId&#10;        AND SelectionId = $SelectionId&#10;        AND Price = $Price&quot;;&#10;&#10;        command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId);&#10;        command.Parameters.AddWithValue(&quot;$SelectionId&quot;, selectionId);&#10;        command.Parameters.AddWithValue(&quot;$Price&quot;, price ?? (object)DBNull.Value);&#10;&#10;        //Console.WriteLine($&quot;Checking if data exists in table {tableName} for MarketId: {marketId}, SelectionId: {selectionId}, Price: {price}&quot;);&#10;        var count = await command.ExecuteScalarAsync();&#10;        //Console.WriteLine($&quot;Data exists: {(long)count &gt; 0}&quot;);&#10;        return (long)count &gt; 0;&#10;    }&#10;&#10;    private async Task ResetAutoIncrementCounters(SqliteConnection connection, List&lt;string&gt; tableNames)&#10;    {&#10;        foreach (var table in tableNames)&#10;        {&#10;            using var resetCommand = connection.CreateCommand();&#10;            resetCommand.CommandText = $&quot;DELETE FROM SQLITE_SEQUENCE WHERE NAME = '{table}'&quot;;&#10;            await resetCommand.ExecuteNonQueryAsync();&#10;        }&#10;    }&#10;&#10;    private async Task DeleteExistingHorseRecord(SqliteConnection connection, string marketId, long selectionId)&#10;    {&#10;        using var deleteCommand = connection.CreateCommand();&#10;        deleteCommand.CommandText = &quot;DELETE FROM HorseMarketBook WHERE MarketId = @MarketId AND SelectionId = @SelectionId&quot;;&#10;        deleteCommand.Parameters.AddWithValue(&quot;@MarketId&quot;, marketId);&#10;        deleteCommand.Parameters.AddWithValue(&quot;@SelectionId&quot;, selectionId);&#10;        await deleteCommand.ExecuteNonQueryAsync();&#10;    }&#10;&#10;    public async Task DeleteFinishedRacesAsync()&#10;    {&#10;        // Method removed as per request to avoid deletion logic.&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Text.Json;&#10;using Microsoft.Data.Sqlite;&#10;using Betfair.Models.Market;&#10;using Betfair.Models.Runner;&#10;using Dapper;&#10;&#10;namespace Betfair.Data;&#10;&#10;public class MarketInfo&#10;{&#10;    public string? MarketName { get; set; }&#10;    public string? EventName { get; set; }&#10;&#10;    public void Deconstruct(out string? marketName, out string? eventName)&#10;    {&#10;        marketName = MarketName;&#10;        eventName = EventName;&#10;    }&#10;}&#10;&#10;public class MarketBookDb&#10;{&#10;    private readonly string _connectionString;&#10;&#10;    public MarketBookDb(string connectionString)&#10;    {&#10;        _connectionString = connectionString;&#10;        try&#10;        {&#10;            VerifyHorseMarketBookSchema();&#10;        }&#10;        catch (Exception)&#10;        {&#10;            // Log or handle initialization errors if necessary&#10;        }&#10;    }&#10;&#10;    private void VerifyHorseMarketBookSchema()&#10;    {&#10;        using var connection = new SqliteConnection(_connectionString);&#10;        connection.Open();&#10;        var cmd = connection.CreateCommand();&#10;        cmd.CommandText = &quot;PRAGMA table_info(HorseMarketBook);&quot;;&#10;&#10;        using var reader = cmd.ExecuteReader();&#10;        while (reader.Read())&#10;        {&#10;            string colName = reader.GetString(1);&#10;            if (colName.Equals(&quot;DAM_YEAR_BORN&quot;, StringComparison.OrdinalIgnoreCase))&#10;            {&#10;                // Column exists, no further action needed&#10;            }&#10;        }&#10;    }&#10;    public async Task InsertHorseMarketBooksIntoDatabase(List&lt;MarketBook&lt;RunnerFlat&gt;&gt; marketBooks)&#10;{&#10;    Console.WriteLine($&quot; InsertHorseMarketBooksIntoDatabase called with {marketBooks?.Count ?? 0} market books&quot;);&#10;    &#10;    if (marketBooks == null || !marketBooks.Any())&#10;    {&#10;        Console.WriteLine(&quot;❌ No market books provided - returning early&quot;);&#10;        return;&#10;    }&#10;&#10;    using var connection = new SqliteConnection(_connectionString);&#10;    await connection.OpenAsync();&#10;    using var transaction = await connection.BeginTransactionAsync();&#10;&#10;    int successfulRunnerInserts = 0;&#10;    int skippedMarketBooks = 0;&#10;&#10;    try&#10;    {&#10;        foreach (var marketBook in marketBooks)&#10;        {&#10;            string marketId = marketBook.MarketId;&#10;            Console.WriteLine($&quot; Processing market: {marketId}&quot;);&#10;&#10;            if (string.IsNullOrEmpty(marketId))&#10;            {&#10;                Console.WriteLine(&quot;⚠️ Skipping market with empty MarketId&quot;);&#10;                skippedMarketBooks++;&#10;                continue;&#10;            }&#10;&#10;            Console.WriteLine($&quot; Processing market: {marketId} with {marketBook.Runners?.Count ?? 0} runners&quot;);&#10;&#10;            var marketInfo = await GetMarketNameAndEventNameByMarketId(connection, marketId);&#10;            string marketName = marketInfo?.MarketName ?? &quot;Unknown&quot;;&#10;&#10;            foreach (var runner in marketBook.Runners)&#10;            {&#10;                if (runner.SelectionId == null)&#10;                {&#10;                    Console.WriteLine(&quot;⚠️ Skipping runner with null SelectionId&quot;);&#10;                    continue;&#10;                }&#10;&#10;                // Check if this specific horse already exists&#10;                var existingHorse = await connection.ExecuteScalarAsync&lt;int&gt;(&#10;                    &quot;SELECT COUNT(1) FROM HorseMarketBook WHERE MarketId = @MarketId AND SelectionId = @SelectionId&quot;,&#10;                    new { MarketId = marketId, SelectionId = runner.SelectionId });&#10;&#10;                if (existingHorse &gt; 0)&#10;                {&#10;                    // Delete this specific horse's old record&#10;                    await DeleteExistingHorseRecord(connection, marketId, runner.SelectionId);&#10;                    Console.WriteLine($&quot; Replacing existing data for horse {runner.SelectionId} in market {marketId}&quot;);&#10;                }&#10;&#10;                // Log the OwnerName for debugging purposes&#10;                Console.WriteLine($&quot;✅ Inserting Runner: SelectionId={runner.SelectionId}, Name={runner.RunnerName}, OwnerName={runner.OwnerName}&quot;);&#10;&#10;                var paramValues = new Dictionary&lt;string, object?&gt;&#10;                {&#10;                    [&quot;MarketId&quot;] = marketId,&#10;                    [&quot;MarketName&quot;] = marketName,&#10;                    [&quot;EventName&quot;] = marketInfo?.EventName ?? &quot;Unknown&quot;,&#10;                    [&quot;SelectionId&quot;] = runner.SelectionId,&#10;                    [&quot;RunnerName&quot;] = runner.RunnerName,&#10;                    [&quot;Status&quot;] = runner.Status,&#10;                    [&quot;SIRE_NAME&quot;] = runner.SireName,&#10;                    [&quot;CLOTH_NUMBER_ALPHA&quot;] = runner.ClothNumberAlpha,&#10;                    [&quot;OFFICIAL_RATING&quot;] = ParseNullableDouble(runner.OfficialRating),&#10;                    [&quot;COLOURS_DESCRIPTION&quot;] = runner.ColoursDescription,&#10;                    [&quot;COLOURS_FILENAME&quot;] = runner.ColoursFilename,&#10;                    [&quot;FORECASTPRICE_DENOMINATOR&quot;] = ParseNullableInt(runner.ForecastPriceDenominator),&#10;                    [&quot;DAMSIRE_NAME&quot;] = runner.DamsireName,&#10;                    [&quot;WEIGHT_VALUE&quot;] = ParseNullableDouble(runner.WeightValue),&#10;                    [&quot;SEX_TYPE&quot;] = runner.SexType,&#10;                    [&quot;DAYS_SINCE_LAST_RUN&quot;] = ParseNullableInt(runner.DaysSinceLastRun),&#10;                    [&quot;WEARING&quot;] = runner.Wearing,&#10;                    [&quot;OWNER_NAME&quot;] = runner.OwnerName,&#10;                    [&quot;DAM_YEAR_BORN&quot;] = ParseNullableInt(runner.DamYearBorn),&#10;                    [&quot;SIRE_BRED&quot;] = runner.SireBred,&#10;                    [&quot;JOCKEY_NAME&quot;] = runner.JockeyName,&#10;                    [&quot;DAM_BRED&quot;] = runner.DamBred,&#10;                    [&quot;ADJUSTED_RATING&quot;] = ParseNullableDouble(runner.AdjustedRating),&#10;                    [&quot;CLOTH_NUMBER&quot;] = runner.ClothNumber,&#10;                    [&quot;SIRE_YEAR_BORN&quot;] = ParseNullableInt(runner.SireYearBorn),&#10;                    [&quot;TRAINER_NAME&quot;] = runner.TrainerName,&#10;                    [&quot;COLOUR_TYPE&quot;] = runner.ColourType,&#10;                    [&quot;AGE&quot;] = ParseNullableInt(runner.Age),&#10;                    [&quot;DAMSIRE_BRED&quot;] = runner.DamsireBred,&#10;                    [&quot;JOCKEY_CLAIM&quot;] = ParseNullableDouble(runner.JockeyClaim),&#10;                    [&quot;FORM&quot;] = runner.Form,&#10;                    [&quot;FORECASTPRICE_NUMERATOR&quot;] = ParseNullableInt(runner.ForecastPriceNumerator),&#10;                    [&quot;BRED&quot;] = runner.Bred,&#10;                    [&quot;DAM_NAME&quot;] = runner.DamName,&#10;                    [&quot;DAMSIRE_YEAR_BORN&quot;] = ParseNullableInt(runner.DamsireYearBorn),&#10;                    [&quot;STALL_DRAW&quot;] = ParseNullableInt(runner.StallDraw),&#10;                    [&quot;WEIGHT_UNITS&quot;] = runner.WeightUnits&#10;                };&#10;&#10;                using var command = connection.CreateCommand();&#10;                command.CommandText = @&quot;&#10;                INSERT INTO HorseMarketBook (&#10;                    MarketId, MarketName, EventName, SelectionId, RUNNER_NAME, Status,&#10;                    SIRE_NAME, STALL_DRAW, DAMSIRE_NAME, FORM, WEIGHT_VALUE,&#10;                    SEX_TYPE, DAYS_SINCE_LAST_RUN, WEARING, OWNER_NAME, DAM_YEAR_BORN,&#10;                    SIRE_BRED, JOCKEY_NAME, DAM_BRED, CLOTH_NUMBER, SIRE_YEAR_BORN,&#10;                    TRAINER_NAME, COLOUR_TYPE, AGE, DAMSIRE_BRED, JOCKEY_CLAIM,&#10;                    FORECASTPRICE_NUMERATOR, BRED, DAM_NAME, DAMSIRE_YEAR_BORN, WEIGHT_UNITS,&#10;                    CLOTH_NUMBER_ALPHA, OFFICIAL_RATING, COLOURS_DESCRIPTION, COLOURS_FILENAME,&#10;                    FORECASTPRICE_DENOMINATOR&#10;                ) VALUES (&#10;                    $MarketId, $MarketName, $EventName, $SelectionId, $RunnerName, $Status,&#10;                    $SIRE_NAME, $STALL_DRAW, $DAMSIRE_NAME, $FORM, $WEIGHT_VALUE,&#10;                    $SEX_TYPE, $DAYS_SINCE_LAST_RUN, $WEARING, $OWNER_NAME, $DAM_YEAR_BORN,&#10;                    $SIRE_BRED, $JOCKEY_NAME, $DAM_BRED, $CLOTH_NUMBER, $SIRE_YEAR_BORN,&#10;                    $TRAINER_NAME, $COLOUR_TYPE, $AGE, $DAMSIRE_BRED, $JOCKEY_CLAIM,&#10;                    $FORECASTPRICE_NUMERATOR, $BRED, $DAM_NAME, $DAMSIRE_YEAR_BORN, $WEIGHT_UNITS,&#10;                    $CLOTH_NUMBER_ALPHA, $OFFICIAL_RATING, $COLOURS_DESCRIPTION, $COLOURS_FILENAME,&#10;                    $FORECASTPRICE_DENOMINATOR&#10;                )&quot;;&#10;&#10;                foreach (var kvp in paramValues)&#10;                {&#10;                    command.Parameters.AddWithValue($&quot;${kvp.Key}&quot;, kvp.Value ?? (object)DBNull.Value);&#10;                }&#10;&#10;                await command.ExecuteNonQueryAsync();&#10;                successfulRunnerInserts++;&#10;            }&#10;        }&#10;&#10;        await transaction.CommitAsync();&#10;        Console.WriteLine($&quot;✅ Successfully processed {successfulRunnerInserts} runners across {marketBooks.Count} market books.&quot;);&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        Console.WriteLine($&quot;❌ Error inserting horse market books: {ex.Message}&quot;);&#10;        Console.WriteLine($&quot;Stack trace: {ex.StackTrace}&quot;);&#10;        await transaction.RollbackAsync();&#10;    }&#10;}&#10;&#10;    public async Task InsertMarketBooksIntoDatabase(List&lt;MarketBook&lt;ApiRunner&gt;&gt; marketBooks)&#10;    {&#10;        Console.WriteLine($&quot; InsertMarketBooksIntoDatabase called with {marketBooks?.Count ?? 0} market books&quot;);&#10;        &#10;        if (marketBooks == null || !marketBooks.Any())&#10;        {&#10;            Console.WriteLine(&quot;❌ No market books provided to InsertMarketBooksIntoDatabase - returning early&quot;);&#10;            return;&#10;        }&#10;&#10;        using var connection = new SqliteConnection(_connectionString);&#10;        await connection.OpenAsync();&#10;        Console.WriteLine($&quot; Database connection opened for back/lay price insertion&quot;);&#10;&#10;        using var transaction = await connection.BeginTransactionAsync();&#10;&#10;        await DeleteExistingData(connection, new List&lt;string&gt; { &quot;MarketBookBackPrices&quot;, &quot;MarketBookLayPrices&quot; });&#10;        await ResetAutoIncrementCounters(connection, new List&lt;string&gt; { &quot;MarketBookBackPrices&quot;, &quot;MarketBookLayPrices&quot; });&#10;&#10;        int totalBackPrices = 0;&#10;        int totalLayPrices = 0;&#10;        int processedMarkets = 0;&#10;&#10;        try&#10;        {&#10;            foreach (var marketBook in marketBooks)&#10;            {&#10;                string marketId = marketBook.MarketId;&#10;                Console.WriteLine($&quot; Processing market {marketId} with {marketBook.Runners?.Count ?? 0} runners for back/lay prices&quot;);&#10;                processedMarkets++;&#10;&#10;                foreach (var runner in marketBook.Runners)&#10;                {&#10;                    Console.WriteLine($&quot; Processing runner {runner.SelectionId} with exchange data: {runner.Exchange != null}&quot;);&#10;                    &#10;                    if (runner.Exchange != null)&#10;                    {&#10;                        Console.WriteLine($&quot; Runner {runner.SelectionId} has {runner.Exchange.AvailableToBack?.Count ?? 0} back prices and {runner.Exchange.AvailableToLay?.Count ?? 0} lay prices&quot;);&#10;&#10;                        foreach (var back in runner.Exchange.AvailableToBack)&#10;                        {&#10;                            if (await IsDataExist(connection, &quot;MarketBookBackPrices&quot;, marketId, runner.SelectionId, back.Price))&#10;                            {&#10;                                Console.WriteLine($&quot;⚠️ Skipping duplicate Back bet data for Runner {runner.SelectionId}: Price = {back.Price}&quot;);&#10;                                continue;&#10;                            }&#10;&#10;                            using var priceCommand = connection.CreateCommand();&#10;                            priceCommand.CommandText = @&quot;&#10;                                INSERT INTO MarketBookBackPrices&#10;                                (MarketId, SelectionId, Price, Size, Status, LastPriceTraded, TotalMatched)&#10;                                VALUES&#10;                                ($MarketId, $SelectionId, $Price, $Size, $Status, $LastPriceTraded, $TotalMatched)&quot;;&#10;&#10;                            priceCommand.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Price&quot;, (double)back.Price);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Size&quot;, (double)back.Size);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$LastPriceTraded&quot;, runner.LastPriceTraded ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$TotalMatched&quot;, runner.TotalMatched ?? (object)DBNull.Value);&#10;&#10;                            await priceCommand.ExecuteNonQueryAsync();&#10;                            totalBackPrices++;&#10;                            Console.WriteLine($&quot;✅ Inserted back price: Market={marketId}, Runner={runner.SelectionId}, Price={back.Price}, Size={back.Size}&quot;);&#10;                        }&#10;&#10;                        foreach (var lay in runner.Exchange.AvailableToLay)&#10;                        {&#10;                            if (await IsDataExist(connection, &quot;MarketBookLayPrices&quot;, marketId, runner.SelectionId, lay.Price))&#10;                            {&#10;                                Console.WriteLine($&quot;⚠️ Skipping duplicate Lay bet data for Runner {runner.SelectionId}: Price = {lay.Price}&quot;);&#10;                                continue;&#10;                            }&#10;&#10;                            using var priceCommand = connection.CreateCommand();&#10;                            priceCommand.CommandText = @&quot;&#10;                                INSERT INTO MarketBookLayPrices&#10;                                (MarketId, SelectionId, Price, Size, Status, LastPriceTraded, TotalMatched)&#10;                                VALUES&#10;                                ($MarketId, $SelectionId, $Price, $Size, $Status, $LastPriceTraded, $TotalMatched)&quot;;&#10;&#10;                            priceCommand.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Price&quot;, (double)lay.Price);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Size&quot;, (double)lay.Size);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$LastPriceTraded&quot;, runner.LastPriceTraded ?? (object)DBNull.Value);&#10;                            priceCommand.Parameters.AddWithValue(&quot;$TotalMatched&quot;, runner.TotalMatched ?? (object)DBNull.Value);&#10;&#10;                            await priceCommand.ExecuteNonQueryAsync();&#10;                            totalLayPrices++;&#10;                            Console.WriteLine($&quot;✅ Inserted lay price: Market={marketId}, Runner={runner.SelectionId}, Price={lay.Price}, Size={lay.Size}&quot;);&#10;                        }&#10;                    }&#10;                    else&#10;                    {&#10;                        Console.WriteLine($&quot;❌ Runner {runner.SelectionId} has no exchange data&quot;);&#10;                    }&#10;                }&#10;            }&#10;            await transaction.CommitAsync();&#10;            Console.WriteLine($&quot; Market book back/lay prices inserted successfully!&quot;);&#10;            Console.WriteLine($&quot; Total processed: {processedMarkets} markets, {totalBackPrices} back prices, {totalLayPrices} lay prices&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            await transaction.RollbackAsync();&#10;            Console.WriteLine($&quot;❌ Error inserting market book prices: {ex.Message}&quot;);&#10;            Console.WriteLine($&quot; Stack trace: {ex.StackTrace}&quot;);&#10;        }&#10;    }&#10;&#10;&#10;    public async Task InsertGreyhoundMarketBooksIntoDatabase(List&lt;MarketBook&lt;ApiRunner&gt;&gt; marketBooks)&#10;    {&#10;        using var connection = new SqliteConnection(_connectionString);&#10;        await connection.OpenAsync();&#10;        using var transaction = await connection.BeginTransactionAsync();&#10;&#10;        try&#10;        {&#10;            foreach (var marketBook in marketBooks)&#10;            {&#10;                string marketId = marketBook.MarketId;&#10;                var marketInfo = await GetMarketNameAndEventNameByMarketId(connection, marketId);&#10;&#10;                foreach (var runner in marketBook.Runners)&#10;                {&#10;                    if (runner.Exchange?.AvailableToBack != null)&#10;                    {&#10;                        foreach (var back in runner.Exchange.AvailableToBack)&#10;                        {&#10;                            using var command = connection.CreateCommand();&#10;                            command.CommandText = @&quot;&#10;                                INSERT INTO GreyhoundMarketBook&#10;                                (MarketId, MarketName, SelectionId, Status, PriceType, Price, Size)&#10;                                VALUES&#10;                                ($MarketId, $MarketName, $SelectionId, $Status, $PriceType, $Price, $Size)&quot;;&#10;&#10;                            command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$MarketName&quot;, marketInfo?.MarketName ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            command.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$PriceType&quot;, &quot;AvailableToBack&quot;);&#10;                            command.Parameters.AddWithValue(&quot;$Price&quot;, (double)back.Price);&#10;                            command.Parameters.AddWithValue(&quot;$Size&quot;, (double)back.Size);&#10;&#10;                            await command.ExecuteNonQueryAsync();&#10;                        }&#10;                    }&#10;&#10;                    if (runner.Exchange?.AvailableToLay != null)&#10;                    {&#10;                        foreach (var lay in runner.Exchange.AvailableToLay)&#10;                        {&#10;                            using var command = connection.CreateCommand();&#10;                            command.CommandText = @&quot;&#10;                                INSERT INTO GreyhoundMarketBook&#10;                                (MarketId, MarketName, SelectionId, Status, PriceType, Price, Size)&#10;                                VALUES&#10;                                ($MarketId, $MarketName, $SelectionId, $Status, $PriceType, $Price, $Size)&quot;;&#10;&#10;                            command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$MarketName&quot;, marketInfo?.MarketName ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$SelectionId&quot;, runner.SelectionId);&#10;                            command.Parameters.AddWithValue(&quot;$Status&quot;, runner.Status ?? (object)DBNull.Value);&#10;                            command.Parameters.AddWithValue(&quot;$PriceType&quot;, &quot;AvailableToLay&quot;);&#10;                            command.Parameters.AddWithValue(&quot;$Price&quot;, (double)lay.Price);&#10;                            command.Parameters.AddWithValue(&quot;$Size&quot;, (double)lay.Size);&#10;&#10;                            await command.ExecuteNonQueryAsync();&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            await transaction.CommitAsync();&#10;            //Console.WriteLine(&quot;Greyhound market books inserted successfully.&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            await transaction.RollbackAsync();&#10;            //Console.WriteLine($&quot;Error inserting greyhound market books: {ex.Message}&quot;);&#10;            //Console.WriteLine(ex.ToString());&#10;        }&#10;    }&#10;&#10;    public async Task&lt;List&lt;HorseMarketBook&gt;&gt; GetHorseMarketBooksAsync()&#10;{&#10;    using var connection = new SqliteConnection(_connectionString);&#10;    await connection.OpenAsync();&#10;&#10;    var query = @&quot;SELECT MarketId, MarketName, EventName, SelectionId, RUNNER_NAME as RunnerName, Status, SIRE_NAME as SireName, DAMSIRE_NAME as DamsireName, TRAINER_NAME as TrainerName, AGE, WEIGHT_VALUE as WeightValue, COLOUR_TYPE as ColourType, FORM FROM HorseMarketBook&quot;;&#10;    var result = await connection.QueryAsync&lt;HorseMarketBook&gt;(query);&#10;&#10;    return result.ToList();&#10;}&#10;&#10;    private async Task&lt;MarketInfo&gt; GetMarketNameAndEventNameByMarketId(SqliteConnection connection, string marketId)&#10;    {&#10;        using var command = connection.CreateCommand();&#10;        command.CommandText = @&quot;&#10;        SELECT MarketName, EventName&#10;        FROM EventMarkets&#10;        WHERE MarketId = $MarketId&#10;        LIMIT 1&quot;;&#10;        command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId);&#10;&#10;        using var reader = await command.ExecuteReaderAsync();&#10;        if (await reader.ReadAsync())&#10;        {&#10;            return new MarketInfo&#10;            {&#10;                MarketName = reader.GetString(0),&#10;                EventName = reader.GetString(1)&#10;            };&#10;        }&#10;&#10;        Console.WriteLine($&quot;No matching MarketId found in EventMarkets for MarketId: {marketId}&quot;);&#10;        return new MarketInfo { MarketName = &quot;Unknown&quot;, EventName = &quot;Unknown&quot; };&#10;    }&#10;&#10;    private static int? ParseNullableInt(string input) =&gt;&#10;        int.TryParse(input, out var result) ? result : null;&#10;&#10;    private static double? ParseNullableDouble(string input) =&gt;&#10;        double.TryParse(input, out var result) ? result : null;&#10;&#10;    private async Task DeleteExistingData(SqliteConnection connection, List&lt;string&gt; tableNames)&#10;    {&#10;        // Method removed as per request to avoid deletion logic.&#10;    }&#10;&#10;    private async Task&lt;bool&gt; IsDataExist(SqliteConnection connection, string tableName, object marketId, object selectionId, object price)&#10;    {&#10;        using var command = connection.CreateCommand();&#10;        command.CommandText = $@&quot;&#10;        SELECT COUNT(1)&#10;        FROM {tableName}&#10;        WHERE MarketId = $MarketId&#10;        AND SelectionId = $SelectionId&#10;        AND Price = $Price&quot;;&#10;&#10;        command.Parameters.AddWithValue(&quot;$MarketId&quot;, marketId);&#10;        command.Parameters.AddWithValue(&quot;$SelectionId&quot;, selectionId);&#10;        command.Parameters.AddWithValue(&quot;$Price&quot;, price ?? (object)DBNull.Value);&#10;&#10;        //Console.WriteLine($&quot;Checking if data exists in table {tableName} for MarketId: {marketId}, SelectionId: {selectionId}, Price: {price}&quot;);&#10;        var count = await command.ExecuteScalarAsync();&#10;        //Console.WriteLine($&quot;Data exists: {(long)count &gt; 0}&quot;);&#10;        return (long)count &gt; 0;&#10;    }&#10;&#10;    private async Task ResetAutoIncrementCounters(SqliteConnection connection, List&lt;string&gt; tableNames)&#10;    {&#10;        foreach (var table in tableNames)&#10;        {&#10;            using var resetCommand = connection.CreateCommand();&#10;            resetCommand.CommandText = $&quot;DELETE FROM SQLITE_SEQUENCE WHERE NAME = '{table}'&quot;;&#10;            await resetCommand.ExecuteNonQueryAsync();&#10;        }&#10;    }&#10;&#10;    private async Task DeleteExistingHorseRecord(SqliteConnection connection, string marketId, long selectionId)&#10;    {&#10;        using var deleteCommand = connection.CreateCommand();&#10;        deleteCommand.CommandText = &quot;DELETE FROM HorseMarketBook WHERE MarketId = @MarketId AND SelectionId = @SelectionId&quot;;&#10;        deleteCommand.Parameters.AddWithValue(&quot;@MarketId&quot;, marketId);&#10;        deleteCommand.Parameters.AddWithValue(&quot;@SelectionId&quot;, selectionId);&#10;        await deleteCommand.ExecuteNonQueryAsync();&#10;    }&#10;&#10;    public async Task DeleteFinishedRacesAsync()&#10;    {&#10;        // Method removed as per request to avoid deletion logic.&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Betfair/place_bets.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Betfair/place_bets.py" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>